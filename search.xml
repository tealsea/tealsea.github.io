<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>node爬虫-妹子图</title>
      <link href="/posts/mzitu/"/>
      <url>/posts/mzitu/</url>
      
        <content type="html"><![CDATA[<h2 id="使用node爬虫"><a href="#使用node爬虫" class="headerlink" title="使用node爬虫"></a>使用node爬虫</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><ul><li><a href="https://nodejs.org/zh-cn/">安装node</a>h环境</li><li>npm  install cheerio</li><li>npm install axios</li></ul><pre><code>const fs = require(&#39;fs&#39;),    cheerio = require(&#39;cheerio&#39;),    axios = require(&#39;axios&#39;),    URL = &#39;https://www.mzitu.com/246652/2&#39;;getImg(URL)// 获取页面信息async function getImg(url) &#123;    const html = await axios.get(url)    const $ = cheerio.load(html.data);    const imgSrc = $(&#39;.main-image img&#39;).attr(&#39;src&#39;);    const imgTitle = $(&#39;.main-image img&#39;).attr(&#39;alt&#39;);    const nextImgSrc = $(&#39;.main-image a&#39;).attr(&#39;href&#39;);    createDir(imgSrc, imgTitle, nextImgSrc);&#125;;// 创建分组文件夹async function createDir(imgSrc, imgTitle, next) &#123;    let reg = /\/(\d+)$/g;    let num = reg.exec(next)[1];    num &gt; 400?num=1:num-1;    //创建文件夹    fs.mkdir(&#39;./&#39;+imgTitle, error=&gt;&#123;        console.log(&#39;正在爬取图片&#39;);    &#125;);    sava(imgTitle, imgSrc, next, num);&#125;;// 将图片保存到本地async function sava(imgTitle, imgSrc, next, num) &#123;    // 判断图片格式    let reg=/\.(bmp|jpg|png|tif|gif|pcx|tga|exif|fpx|svg|psd|cdr|pcd|dxf|ufo|eps|ai|raw|WMF|webp)/g;    let format=reg.exec(imgSrc)[1];    //将图片转化为流的方式    let img = await axios.get(imgSrc, &#123;        responseType: &#39;stream&#39;, headers: &#123;            referer: &#39;https://www.mzitu.com/&#39;        &#125;,    &#125;);    //以流的方式下载到本地    let ws = fs.createWriteStream(`./$&#123;imgTitle&#125;/$&#123;num&#125;.$&#123;format&#125;`);    img.data.pipe(ws);    // 爬取成功触发    ws.on(&#39;finish&#39;, function () &#123;        console.log(&quot;『&quot;+imgTitle+&quot;』&quot; + &#39;-----------------爬取成功&#39;);        //循环下一个图片        getImg(next);    &#125;);&#125;;</code></pre><h3 id="运行图片"><a href="#运行图片" class="headerlink" title="运行图片"></a>运行图片</h3><p><img src="https://ftp.bmp.ovh/imgs/2020/09/1d09100e95910ae6.png" alt="网站代码"></p><p><img src="https://ftp.bmp.ovh/imgs/2020/09/ec328375d815f108.png" alt="运行代码"></p><p><img src="https://ftp.bmp.ovh/imgs/2020/09/df42f565cc20d82c.png" alt="本地输出"></p><h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址:"></a>源码地址:</h4><ul><li><a href="https://gitee.com/tealsea/sister-picture">gitee</a></li><li><a href="https://github.com/tealsea/mzitu">github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript正则的基本使用</title>
      <link href="/posts/jsregexp/"/>
      <url>/posts/jsregexp/</url>
      
        <content type="html"><![CDATA[<h3 id="正则基本符号："><a href="#正则基本符号：" class="headerlink" title="正则基本符号："></a>正则基本符号：</h3><h4 id="量词："><a href="#量词：" class="headerlink" title="量词："></a>量词：</h4><table><thead><tr><th align="center">量词</th><th>使用说明</th></tr></thead><tbody><tr><td align="center">{ n, }</td><td>表示出现n次级n次以上</td></tr><tr><td align="center">{ n }</td><td>表示出现n次</td></tr><tr><td align="center">{ n, m}</td><td>表示出现n到m次</td></tr><tr><td align="center">?</td><td>表示出现零次或一次</td></tr><tr><td align="center">+</td><td>表示出现一次及一次以上</td></tr><tr><td align="center">*</td><td>表示出现零次及零次以上</td></tr></tbody></table><h4 id="元字符："><a href="#元字符：" class="headerlink" title="元字符："></a>元字符：</h4><table><thead><tr><th align="center">元字符</th><th align="left">使用说明</th></tr></thead><tbody><tr><td align="center">\w</td><td align="left">表示数字、字母、下划线</td></tr><tr><td align="center">\W</td><td align="left">表示除了数字、字母、下划线</td></tr><tr><td align="center">\d</td><td align="left">表示0-9之间的数字</td></tr><tr><td align="center">\D</td><td align="left">表示除了0-9之间的数字</td></tr><tr><td align="center">\s</td><td align="left">表示空格、制表符、换行符</td></tr><tr><td align="center">\S</td><td align="left">表示除了空格、制表符、换行符</td></tr><tr><td align="center">\b</td><td align="left">表示单词边界</td></tr><tr><td align="center">\B</td><td align="left">表示除了单词边界</td></tr><tr><td align="center">\t</td><td align="left">表示制表符(一个TAB键：四个空格)</td></tr><tr><td align="center">\n</td><td align="left">表示换行符</td></tr><tr><td align="center">\</td><td align="left">表示转义符</td></tr><tr><td align="center">.</td><td align="left">表示除了\n(换行符)之外的任意字符</td></tr><tr><td align="center">\ .</td><td align="left">表示小数点（单独写点\ .写不出来只能中间加一个空格，真实中没有空格）</td></tr><tr><td align="center">[xzy]</td><td align="left">表示 x 或 z 或 y 中的任意字符</td></tr><tr><td align="center">a|b</td><td align="left">表示 a 或 b</td></tr><tr><td align="center">[a-z]</td><td align="left">表示 a-z 之间小写英文字母中的任意一个</td></tr><tr><td align="center">[A-Z]</td><td align="left">表示A-Z之间大写英文字母中的任意一个</td></tr><tr><td align="center">[0-9]</td><td align="left">表示 0-9 之间任意一个数字</td></tr><tr><td align="center">[ \u4e00-\u9fa5 ]</td><td align="left">表示所有汉字</td></tr><tr><td align="center">^n</td><td align="left">表示以n开始</td></tr><tr><td align="center">m$</td><td align="left">表示以m结尾</td></tr><tr><td align="center">^a$</td><td align="left">表示以a开头还要以a结尾</td></tr><tr><td align="center">( )</td><td align="left">表示分组符号</td></tr><tr><td align="center">( ?: )</td><td align="left">表示只匹配不捕获</td></tr><tr><td align="center">( ?= )</td><td align="left">表示正向预查</td></tr><tr><td align="center">( ?! )</td><td align="left">表示负向预查</td></tr><tr><td align="center">[abcs]</td><td align="left">表示abcs其中一个本身意思</td></tr></tbody></table><h4 id="修饰符："><a href="#修饰符：" class="headerlink" title="修饰符："></a>修饰符：</h4><table><thead><tr><th align="center">修饰符</th><th align="left">使用说明</th></tr></thead><tbody><tr><td align="center">i</td><td align="left">表示忽略大小写</td></tr><tr><td align="center">m</td><td align="left">表示进行多行匹配</td></tr><tr><td align="center">g</td><td align="left">表示进行全局匹配</td></tr></tbody></table><h3 id="创建正则的方式："><a href="#创建正则的方式：" class="headerlink" title="创建正则的方式："></a>创建正则的方式：</h3><ul><li><p>字面量创建</p><pre><code>let str=&#39;teal&#39;let reg=/\w/;//匹配字符串中的数字、字母和下划线console.log(reg.test(str));//true</code></pre></li><li><p>构造函数创建</p><pre><code>let str=&#39;teal&#39;;let reg=new RegExp(&quot;\\w&quot;);console.log(reg.test(str));//true</code></pre></li></ul><h3 id="正则中常用的方法"><a href="#正则中常用的方法" class="headerlink" title="正则中常用的方法"></a>正则中常用的方法</h3><ul><li><p>test </p><ol><li><p>effect:    验证字符串是否存在</p></li><li><p>params: value</p></li><li><p>return:   false | true</p><pre><code>let reg=/[a-z]/;//验证a-z之间的英文console.log(reg.test(&#39;teal&#39;));//true;console.log(reg.test(&#39;1234&#39;));//false</code></pre></li></ol></li><li><p>exec</p><ol><li><p>effect: :验证符合条件的值</p></li><li><p>params: value</p></li><li><p>return: 返回一个数组/null，数组中第一项是匹配的字符串，第二项匹配字符串的位置，第三项是原始字符串，第四项是</p><pre><code>let reg=/[a-z]/;console.log(reg.exec(&#39;teal&#39;));//[&quot;t&quot;, index: 0, input: &quot;teal&quot;, groups: undefined]console.log(reg.exec(2222));//null</code></pre></li></ol></li><li><p>match</p><ol><li><p>effect:验证符合条件所有的值</p></li><li><p>params: reg</p></li><li><p>return:返回一个数组/null，数组中包含所有符合条件的值。</p><pre><code>let reg=/(good)/g;console.log(&#39;good good study day day up!&#39;.match(reg));//[&quot;good&quot;, &quot;good&quot;]console.log(&#39;day day up!&#39;.match(reg));//null</code></pre></li></ol></li><li><p>replace</p><ol><li><p>effect:替换指定的字符串</p></li><li><p>params: reg,value</p></li><li><p>return:替换后的字符串</p><pre><code>let reg=/o/g;console.log(&#39;good good study day day up!&#39;.replace(reg,&#39;a&#39;));//&#39;gaad gaad study day day up!&#39;</code></pre></li></ol></li><li><p>search</p><ol><li><p>effect:查询时字符串中是否包含该字符</p></li><li><p>params:  reg</p></li><li><p>return:返回第一个位置得索引，没找到返回-1</p><pre><code>console.log(&#39;abc&#39;.search(/b/g));//1console.log?(&#39;abbc&#39;.search(/d/));//-1</code></pre></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queryUrlParams</title>
      <link href="/posts/toolsqueryurlparams/"/>
      <url>/posts/toolsqueryurlparams/</url>
      
        <content type="html"><![CDATA[<pre><code>/* * params: 无 * return: 返回一个对象，对象中存储url中的数据 */~ function() &#123;    //封装获取url参数    function queryUrlParams() &#123;        let obj = &#123;&#125;;//定义一个空对象        this.replace(/([^?#&amp;=]+)=([^?#&amp;=]+)/g, (...[, $1, $2]) =&gt; &#123; /获取参数            obj[$1] = $2//将参数存储到对象中        &#125;);        this.replace(/#([^=&amp;?#]+)/g, (...[, $1]) =&gt; &#123; //获取哈希值            obj[&#39;HASH&#39;] = $1;//将哈希值存储到对象中        &#125;);        return obj;/将对象返回    &#125;;    String.prototype[&#39;queryUrlParams&#39;] = queryUrlParams; //挂载到原型&#125;();//测试let url1 = &#39;www.baidu.com/?name=teal&amp;age=29#video&#39;;console.log(url1.queryUrlParams()); /&#123;name: &quot;teal&quot;, age: &quot;29&quot;, HASH: &quot;video&quot;&#125;let url2 = &#39;www.baidu.com/?name=teal&amp;age=29&#39;;console.log(url2.queryUrlParams()); /&#123;name: &quot;teal&quot;, age: &quot;29&quot;&#125;let url3 = &#39;www.baidu.com/#video&#39;;console.log(url3.queryUrlParams()); /&#123;HASH: &quot;video&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装时间格式</title>
      <link href="/posts/toolsformattime/"/>
      <url>/posts/toolsformattime/</url>
      
        <content type="html"><![CDATA[<pre><code>/* * params: 任意参数分割日期，默认汉字格式 * return: 返回指定格式日期 */~ function() &#123;    // 封装格式日期函数    function formatTime(format = &#39;cn&#39;) &#123; //格式默认为中文        time = this.match(/\d+/g);//将日期拆分成数组        let template = format === &#39;cn&#39; ? &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot; : `&#123;0&#125;$&#123;format&#125;&#123;1&#125;$&#123;format&#125;&#123;2&#125; &#123;3&#125;:&#123;4&#125;:&#123;5&#125;`;//判断日期模板        return template = template.replace(/\&#123;(\d+)\&#125;/g, (content, $1) =&gt; &#123; //将模板中指定内容替换            let newtime = time[$1] || &quot;00&quot;;// 自动将缺少的时间变为00            return newtime = newtime.length &lt; 2 ? &quot;0&quot; + newtime : newtime;//将小于两位的时间前面加一个字符串0        &#125;);    &#125;;    String.prototype[&#39;formatTime&#39;] = formatTime;//挂载到字符串原型&#125;();//测试let time1=&#39;2020年9月22号 12:22:33&#39;;console.log(time1.formatTime());//&#39;2020年09月22日 12时22分33秒&#39;let time2=&#39;2020年9月22号&#39;;console.log(time2.formatTime());//&#39;2020年09月22日 00时00分00秒&#39;let time3=&#39;2020年9月22号 12:22:33&#39;;console.log(time3.formatTime(&#39;-&#39;));//&#39;2020-09-22 12:22:33&#39;let time4=&#39;2020年9月22号&#39;;console.log(time4.formatTime(&#39;+&#39;));//&#39;2020+09+22 00:00:00&#39;let time5=&#39;2020-09-22 12:22:33&#39;;console.log(time5.formatTime());//&#39;2020年09月22日 12时22分33秒&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的基本使用</title>
      <link href="/posts/git/"/>
      <url>/posts/git/</url>
      
        <content type="html"><![CDATA[<h2 id="git的基本使用"><a href="#git的基本使用" class="headerlink" title="git的基本使用"></a>git的基本使用</h2><ol><li><p>初始化一个本地的git仓库</p><pre class=" language-shell"><code class="language-shell">$ git init; // 初始化git仓库</code></pre></li><li><p>将工作区代码提交到暂存区</p><pre class=" language-shell"><code class="language-shell">$ git status;// 查看工作区代码$ git add . / git add -A;// 将代码提交暂存区</code></pre></li><li><p>将暂存区代码提交到历史区</p><pre class=" language-shell"><code class="language-shell">$ git commit -m'项目描述';//将暂存区代码提交到历史区$ git log;// 查看首次历史版本信息$ git reflog;// 查看所有的历史版本信息及操作$ git reset --hard 历史版本号;//回退到指定的版本</code></pre></li><li><p>把本地代码提交到远程仓库</p><ol><li><p>创建 github账号</p></li><li><p>创建一个新的远程仓库</p></li><li><p>将本地仓库和远程仓库进行连接</p><pre class=" language-shell"><code class="language-shell">$ git remote -V;//查看连接状态$ git remote add origin 仓库地址;//将本地仓库和远程仓库建立连接$ git remote rm origin;//删除本地仓库和远程仓库的关联$ git remote pull origin master;//拉取远程仓库最新的代码$ git remote push origin master;//将本地代码上传到远程仓库</code></pre></li></ol></li><li><p>克隆仓库</p><ol><li><p>创建一个仓库</p></li><li><p>点击code查看仓库地址</p></li><li><p>在本地进行克隆</p><pre class=" language-shell"><code class="language-shell">$ git clone 仓库地址</code></pre><blockquote><p>克隆的好处？</p><ol><li>克隆可以自动初始化仓库</li><li>克隆自动和远程仓库进行连接</li><li>克隆可以将仓库内容拉取到本地</li></ol></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios封装使用</title>
      <link href="/posts/toolsaxios/"/>
      <url>/posts/toolsaxios/</url>
      
        <content type="html"><![CDATA[<pre><code>//下载 axios &amp;&amp; qs// 导出axios模块import axios from &#39;axios&#39;// 导入qs模块import qs from &#39;qs&#39;// 设置开发环境(生产环境)switch (process.env.NODE_ENV) &#123;    case &#39;production&#39;:        axios.defaults.baseURL = &#39;http://tealseaproduction:80&#39;;// 开发环境        break;    case &#39;test&#39;:        axios.defaults.baseURL = &#39;http://tealseatest:3000&#39;;// 测试环境        break;    default:        axios.defaults.baseURL = &#39;http://tealseadevelop:3000&#39;;// 开发环境&#125;;// 设置超时时间(十秒)axios.defaults.timeou = 10000;// 设置跨域请求携带凭证(是)axios.defaults.withCredentials = true;//设置请求参数格式(x-www-form-urlencoded)axios.defaults.headers[&#39;Content-Type&#39;] = &quot;application/x-www-form-urlencoded&quot;;// 格式xxx=xxx&amp;&amp;xxx=xxx//将json格式转换为x-www-form-urlencoded格式[ tranformRequest只对post请求起作用, data是传递的参数 ]axios.defaults.transformRequest = data =&gt; qs.stringify(data);//将&#123;name=xxx,age=xx&#125;=&gt;name=xxx&amp;&amp;age=xx// 请求拦截器axios.interceptors.request.use(config =&gt; &#123;    // 携带本地存储的token    let token = localStorage.getItem(&#39;token&#39;);    token &amp;&amp; (config.headers.Authorization = token);    return config;&#125;, error =&gt; &#123;    // 将失败信息返回    return Promise.reject(error);&#125;);// 相应拦截器axios.interceptors.response.use(response =&gt; &#123;    // 直接返回数据    return response.data;&#125;, error =&gt; &#123;    let &#123; response &#125; = error;    // 判断是否有数据返回    if (response) &#123;        // 判断返回状态码，来判断错误问题        switch (response.status) &#123;            case 401://一般是未登录                break;            case 403://一般为token                break;            case 404: //找不到页面地址                break;        &#125;;        // 服务器什么都没返回    &#125; else &#123;        // 断网状态        if (!window.navigator.onLine) &#123;            console.log(&#39;没有网络&#39;);            return        &#125;;        // 服务器有问题        return Promise.reject(error);    &#125;;&#125;);// 将axios暴露出去export default axios;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm的使用</title>
      <link href="/posts/npm/"/>
      <url>/posts/npm/</url>
      
        <content type="html"><![CDATA[<h2 id="npm的基本使用"><a href="#npm的基本使用" class="headerlink" title="npm的基本使用"></a>npm的基本使用</h2><p><a href="https://www.npmjs.com/">npmjs</a>：基于npm下载安装平台</p><pre class=" language-powershell"><code class="language-powershell">$ npm install xx<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span>下载完成后会在本地项目中生成（node_modules）的管理文件夹保存模块$ npm install xx <span class="token operator">-</span>g<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 全局安装模块$ npm install xx@1<span class="token punctuation">.</span>xx<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>下载指定的的版本的模块$ npm init <span class="token operator">-</span>y<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> 初始化项目配置的依赖清单$ npm install xx <span class="token operator">--</span>save<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>把模块保存在清单依赖项中$ npm install xx-<span class="token operator">-</span>save<span class="token operator">-</span>dev<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>把模块保存在开发依赖性中$ npm install<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span>下载清单中的依赖项$ npm uninstall xx<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>卸载指定模块$ npm uninstall xx <span class="token operator">-</span>g<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> 卸载全局下的模块</code></pre>]]></content>
      
      
      <categories>
          
          <category> 包管理模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面向对象介绍</title>
      <link href="/posts/jsoop/"/>
      <url>/posts/jsoop/</url>
      
        <content type="html"><![CDATA[<h4 id="面型对象介绍"><a href="#面型对象介绍" class="headerlink" title="面型对象介绍"></a>面型对象介绍</h4><blockquote><p>面向对象编程需要我们掌握：‘’对象、类、实例“的概念</p><ul><li>对象：万物皆对象</li><li>类：对象的具体细分(按照功能特点进行分类：大类、小类）</li><li>实例：类中具体的一个事物（拿出类别中的具体的一个实例进行研究，那么当前类别下的其他类的实例也具备这些特点个特征）</li></ul><p>整个js就是基于面向对象设计的个开发的出来的语言，我们学习和实战的时候也要按照面向对象的思想去体会和理解。</p></blockquote><h4 id="基于构造函数创建自定义类（constructor）"><a href="#基于构造函数创建自定义类（constructor）" class="headerlink" title="基于构造函数创建自定义类（constructor）"></a>基于构造函数创建自定义类（constructor）</h4><ul><li><p>在普通函数执行的基础上”new xxx()“，这样就不普通函数执行了，而是构造函数执行，当前的函数名称之为”类名“，接受的返回结果是当前类的一个实例。</p></li><li><p>自己创将的类名，最好第一个首字母大写</p></li><li><p>这种构造函数设计模式执行，主要用户组件、类库、插件、框架的封装，平时编写业务逻辑一般不这样处理</p><pre><code>function Fn()&#123;&#125;;var f1=new Fn();//Fn是类 f1是类的实例var f2=new Fn();//发f2也是Fn的实例，他是和f1是分开独立的，互不影响</code></pre></li></ul><h4 id="js中创建值又两种方法"><a href="#js中创建值又两种方法" class="headerlink" title="js中创建值又两种方法"></a>js中创建值又两种方法</h4><ul><li><p>字面量表达式</p></li><li><p>构造函数模式</p><pre><code>var obj=&#123;&#125;;//字面量创建var obj=new Object();//构造函数</code></pre><blockquote><p>不管哪种方式创建出来的都是Object类的实例，而实例之间是独立分开的</p></blockquote></li></ul><h4 id="基本数据类型基于两种不同的模式创建出来的值不一样"><a href="#基本数据类型基于两种不同的模式创建出来的值不一样" class="headerlink" title="基本数据类型基于两种不同的模式创建出来的值不一样"></a>基本数据类型基于两种不同的模式创建出来的值不一样</h4><ul><li><p>基于字面量方式创建出来的值是基本数据类型</p></li><li><p>基于构造函数创建出来的值是引用数据类型</p><pre><code>var num1=12;var num2=new Number(12);console.log(typeof num1);//&quot;number&quot;console.log(typeof num2);//&quot;object&quot;</code></pre></li></ul><h4 id="构造函数执行步骤（四步）"><a href="#构造函数执行步骤（四步）" class="headerlink" title="构造函数执行步骤（四步）"></a>构造函数执行步骤（四步）</h4><ul><li><p>跟普通函数执行一样，形成一个私有作用域（栈内存）</p><ul><li>形参赋值</li><li>变量提升</li></ul></li><li><p>[构造函数执行独有]在js中代码自上而下执行之前，首先在当前形成一个栈中创建一个对象（创建一个堆内存，暂时不存储任何东西），并且让函数中执行主体（this）执行这个堆内存（this===新创建的对象）</p></li><li><p>代码自上而下执行</p></li><li><p>[构造函数独有]代码执行完毕，把之前创建的堆内存(也是就是this)地址返回(浏览器默认返回)</p><pre><code>function Fn()&#123;    var n=10;    this.m=n&#125;;var f=new Fn();console.log(f.m); // 10console.log(f.n); // undefined</code></pre></li></ul><h4 id="构造函数执行，不写return浏览器默认返回创建的实例，但是如果我们自己return-返回-会发生什么"><a href="#构造函数执行，不写return浏览器默认返回创建的实例，但是如果我们自己return-返回-会发生什么" class="headerlink" title="构造函数执行，不写return浏览器默认返回创建的实例，但是如果我们自己return(返回)会发生什么?"></a>构造函数执行，不写return浏览器默认返回创建的实例，但是如果我们自己return(返回)会发生什么?</h4><ul><li><p>如果自己return(返回)的是一个基本数据类型，返回的结果依然是类的实例（this），没有任何影响</p><pre><code>function Fn()&#123;    this.name=&#39;teal&#39;;    return 12;&#125;;var f=new Fn();console.log(f);//&#123;name:&#39;teal&#39;&#125;console.log(f.name);//&quot;teal&quot;</code></pre></li><li><p>如果返回的是引用数据类型值，则会把默认返回的实例覆盖，此时接收到的结果就不是当前类的实例了（不再是this,而是我们自己返回的引用数据类型值），所以我们在构造函数中，应尽量避免return的使用，防止覆盖实例</p><pre><code>function Fn()&#123;    this.name=&#39;teal&#39;;    return &#123;age:20&#125;;&#125;;var f=new Fn;//如果构造函数没有实参传递可以不写括号console.log(f);//&#123;age:20&#125;console.log(f.name);//undefinedconsole.log(f.age)// 20</code></pre></li></ul><h4 id="instanceof：检测某一个实例是否隶属于这个类"><a href="#instanceof：检测某一个实例是否隶属于这个类" class="headerlink" title="instanceof：检测某一个实例是否隶属于这个类"></a>instanceof：检测某一个实例是否隶属于这个类</h4><ul><li><p>检测如果属于这个类返回true,不属于返回false</p></li><li><p>万物皆对象，所有的对象包含创建的实例都是Object的实例</p><pre><code>function Fn()&#123;    this.m=10;&#125;;var f=new Fn();console.log(f instanceof Fn);//trueconsole.log(f instanceof Array);//falseconsole.log(f instanceof Object);//true</code></pre></li></ul><h4 id="in-检测当前对象是否存在某一个属性"><a href="#in-检测当前对象是否存在某一个属性" class="headerlink" title="in:检测当前对象是否存在某一个属性"></a>in:检测当前对象是否存在某一个属性</h4><ul><li><p>不管这个属性是对象的私有属性还是公有属性，只要有结果都为true,否则为false</p><pre><code>function Fn()&#123;        var n=10;    this.m=n;&#125;;var f=new Fn();console.log(&#39;m&#39; in f);//trueconsole.log(&#39;n&#39; in f);// false console.log(&#39;toString&#39; in f);// true (toString为供有属性)</code></pre></li></ul><h4 id="hasOwnproperty-检测当前属性是否为对象的私有属性"><a href="#hasOwnproperty-检测当前属性是否为对象的私有属性" class="headerlink" title="hasOwnproperty:检测当前属性是否为对象的私有属性"></a>hasOwnproperty:检测当前属性是否为对象的私有属性</h4><ul><li><p>不仅要包含这个属性，而且必须还是私有属性的才为true,否则为false</p><pre><code>function Fn()&#123;    var n=10;    this.m=n;&#125;;var f=new Fn();console.log(f.hasOwnProperty(&#39;m&#39;));//trueconsole.log(f.hasOwnProperty(&#39;n&#39;));//falseconsole.log(f.hasOwnProperty(&#39;toString&#39;));//false(虽然toString有这个属性，但是他不是私有属性)</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js原型和原型链</title>
      <link href="/posts/jspropotype/"/>
      <url>/posts/jspropotype/</url>
      
        <content type="html"><![CDATA[<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ul><li>所有的函数类型都天生再带一个属性：prototype（原型），这个属性的值是一个对象，浏览器会默认给他开辟一个堆内存</li><li>在浏览器中给prototype（原型）开辟的堆内存中有一个天生自带的属性：constructor,这个属性存储的值是当前函数本身</li><li>每一个对象都有一个__proto__的属性，这个属性指向当前的实例所属类的prototype（如果不能确定他是谁的实例，都是Object的实例） </li></ul><h4 id="原型图"><a href="#原型图" class="headerlink" title="原型图"></a>原型图</h4><p><img src="https://s1.ax1x.com/2020/09/12/waCW7t.md.png" alt="原型图"></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><blockquote><p>他是一种基于__proto__向上查找的机制，当我们操作实例的某一个属性或方法的时候，首先找到自己的私有的属性或方法</p><ul><li>找到了，则结束查找，使用自己私有的属性或方法即可</li><li>没找到，则基于__proto__找到所属类的prototype,如果找到了，就用这个属性或方法，没找到则继续向上查找，一直找到Object.protype的原型为止，如果还没找到，操作的属性或方法不存在</li></ul></blockquote><pre><code>function Fn()&#123;    var n=10;    this.aa=function()&#123;        console.log(&#39;aa私有&#39;);    &#125;;&#125;;Fn.prototype.AA=function()&#123;    console.log(&#39;AA公&#39;);&#125;;var f1=new Fn();var f2=new Fn();console.log(f1.n);//undefinedconsole.log(f1.aa===f2.aa);//falseconsole.log(f1.__proto__.AA===f2.__proto__.AA);//trueconsole.log(f1.hasOwnProperty===Fn.prototype.hasOwnProperty);//true</code></pre><p>原型图</p><p><img src="https://s1.ax1x.com/2020/09/12/waA8sg.md.png" alt="原型图"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> prototype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js字符串中常用的方法</title>
      <link href="/posts/jsstringstudy/"/>
      <url>/posts/jsstringstudy/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>在js中用单引号或双引号，反引号包起来的都是字符串，每一个字符串都是由零到多个字符组成的，个数组类似每一个字符都有自己的索引</p><pre><code>let str=&#39;Hello world&#39;;console.log(str[0]);//“H”console.log(str[1]);//&quot;e&quot;</code></pre><p>str.length存储了一共又多少字符。也就是字符的长度</p><p>遍历字符串的每一个字符</p><pre><code>let str=&quot;Hello world&quot;;for(let i=0;i&lt;str.length;i++)&#123;   console.log(str[i]);// &quot;H&quot;&gt;&quot;e&quot;&gt;&quot;l&quot;&gt;&quot;l&quot;&gt;&quot;o&quot;&gt;&quot; &quot;&gt;&quot;w&quot;&gt;&quot;o&quot;&gt;&quot;r&quot;&gt;&quot;l&quot;&gt;&quot;d&quot;&#125;;</code></pre></blockquote><ul><li><h2 id="字符串中常用的方法"><a href="#字符串中常用的方法" class="headerlink" title="字符串中常用的方法"></a>字符串中常用的方法</h2><ul><li><h4 id="获取指定的位置的值和unicode编码"><a href="#获取指定的位置的值和unicode编码" class="headerlink" title="获取指定的位置的值和unicode编码"></a>获取指定的位置的值和unicode编码</h4><ol><li><h5 id="charAt-value-根据索引获取指定位置的字符-charAt相当于直接基于索引获取的方式，在当前并不存在的情况下，字符串-索引-获取的结果是undefined，而charAt获取的结果为空字符串）"><a href="#charAt-value-根据索引获取指定位置的字符-charAt相当于直接基于索引获取的方式，在当前并不存在的情况下，字符串-索引-获取的结果是undefined，而charAt获取的结果为空字符串）" class="headerlink" title="charAt([value]);根据索引获取指定位置的字符(charAt相当于直接基于索引获取的方式，在当前并不存在的情况下，字符串[索引]获取的结果是undefined，而charAt获取的结果为空字符串）"></a>charAt([value]);根据索引获取指定位置的字符(charAt相当于直接基于索引获取的方式，在当前并不存在的情况下，字符串[索引]获取的结果是undefined，而charAt获取的结果为空字符串）</h5><pre><code>let str=&#39;Hello world&#39;;console.log(str[0]);// &#39;H&#39;console.log(str.charAt(0));// &#39;H&#39;console.log(str[str.length-1]); // &#39;d&#39;console.log(str.charAt(str.length-1));// &#39;d&#39;console.log(str[str.length]);// &#39;undefined&#39;console.log(str.charAt(str.length));// &#39;&#39;</code></pre></li><li><h5 id="charCodeAt-在charAt的基础上获取指定字符的unicode编码（ASSCII码中的值）"><a href="#charCodeAt-在charAt的基础上获取指定字符的unicode编码（ASSCII码中的值）" class="headerlink" title="charCodeAt:在charAt的基础上获取指定字符的unicode编码（ASSCII码中的值）"></a>charCodeAt:在charAt的基础上获取指定字符的unicode编码（ASSCII码中的值）</h5><pre><code>let str=&#39;Hello world&#39;;console.log(str.charCodeAt(0));// 72</code></pre></li><li><h5 id="String-fromCharCode-unicode编码-；和charCodeAt对应，他是基于编码前的字符"><a href="#String-fromCharCode-unicode编码-；和charCodeAt对应，他是基于编码前的字符" class="headerlink" title="String,fromCharCode([unicode编码])；和charCodeAt对应，他是基于编码前的字符"></a>String,fromCharCode([unicode编码])；和charCodeAt对应，他是基于编码前的字符</h5><pre><code>console.log(String.fromCharCode(72)); //&#39;H&#39;</code></pre></li></ol></li><li><h4 id="字符串的截取（最后的m不写，默认都是截取到字符串的末尾）"><a href="#字符串的截取（最后的m不写，默认都是截取到字符串的末尾）" class="headerlink" title="字符串的截取（最后的m不写，默认都是截取到字符串的末尾）"></a>字符串的截取（最后的m不写，默认都是截取到字符串的末尾）</h4><ol><li><h5 id="substr-n-m-从索引n开始-截取m个字符"><a href="#substr-n-m-从索引n开始-截取m个字符" class="headerlink" title="substr(n,m);从索引n开始,截取m个字符"></a>substr(n,m);从索引n开始,截取m个字符</h5><pre><code>let str =&#39;Hello world&#39;;console.log(str.substr(2,3));//&#39;llo&#39;</code></pre></li><li><h5 id="substring-n-m-从索引n开始，找到索引为m处（不包含m）吗，找到的部分截取到"><a href="#substring-n-m-从索引n开始，找到索引为m处（不包含m）吗，找到的部分截取到" class="headerlink" title="substring(n,m);从索引n开始，找到索引为m处（不包含m）吗，找到的部分截取到"></a>substring(n,m);从索引n开始，找到索引为m处（不包含m）吗，找到的部分截取到</h5><pre><code>let str=&#39;Hello world&#39;;console.log(str.substring(2,3));//&#39;l&#39;</code></pre></li><li><h5 id="slice-n-m-和substring是一样的，两个都是根据索引截取，只不过slice支持以负数作为索引"><a href="#slice-n-m-和substring是一样的，两个都是根据索引截取，只不过slice支持以负数作为索引" class="headerlink" title="slice(n,m);和substring是一样的，两个都是根据索引截取，只不过slice支持以负数作为索引"></a>slice(n,m);和substring是一样的，两个都是根据索引截取，只不过slice支持以负数作为索引</h5><pre><code>let str=&#39;Hello world&#39;;console.log(str.substring(-6,-3));// &#39; &#39; &gt;substring只能支持整数作为索引，以负数作为索引，返回空字符console.log(str.slice(-6,-3));//&#39; wo&#39;</code></pre></li></ol></li><li><h4 id="字符串查找是否包含某个字符"><a href="#字符串查找是否包含某个字符" class="headerlink" title="字符串查找是否包含某个字符"></a>字符串查找是否包含某个字符</h4><ol><li><h5 id="indexOf-lastIndexOf-获取当前字符串中第一次或最后一次出现的位置的索引，如果字符串中不包含该字符，返回结果为-1"><a href="#indexOf-lastIndexOf-获取当前字符串中第一次或最后一次出现的位置的索引，如果字符串中不包含该字符，返回结果为-1" class="headerlink" title="indexOf / lastIndexOf ;获取当前字符串中第一次或最后一次出现的位置的索引，如果字符串中不包含该字符，返回结果为-1"></a>indexOf / lastIndexOf ;获取当前字符串中第一次或最后一次出现的位置的索引，如果字符串中不包含该字符，返回结果为-1</h5><pre><code>let str=&#39;Hello world&#39;;console.log(str.indexOf(&#39;o&#39;));// 4console.log(str.lastIndexOf(&#39;o&#39;));// 7console.log(str.indexOf(&#39;z&#39;));// -1console.log(str.lastIndexOf(&#39;z&#39;)); //-1</code></pre></li></ol></li><li><h4 id="字符串大小字符转换"><a href="#字符串大小字符转换" class="headerlink" title="字符串大小字符转换"></a>字符串大小字符转换</h4><ol><li><h5 id="toUpperCase-toLowerCase-把字符串转换为大写或小写"><a href="#toUpperCase-toLowerCase-把字符串转换为大写或小写" class="headerlink" title="toUpperCase / toLowerCase :把字符串转换为大写或小写"></a>toUpperCase / toLowerCase :把字符串转换为大写或小写</h5><pre><code>let str=&#39;HELLO world&#39;;console.log(str.toUpperCase());//&#39;HELLO WORLD&#39;console.log(str.toLowerCase());//&#39;hello world&#39;</code></pre></li></ol></li><li><h4 id="字符串转换为数组的方法"><a href="#字符串转换为数组的方法" class="headerlink" title="字符串转换为数组的方法"></a>字符串转换为数组的方法</h4><ol><li><h5 id="split-和数组中的join方法对应，他是把字符串按照指定的分隔符分隔，拆分成数组中的每一项，返回的结果是一个数组"><a href="#split-和数组中的join方法对应，他是把字符串按照指定的分隔符分隔，拆分成数组中的每一项，返回的结果是一个数组" class="headerlink" title="split:和数组中的join方法对应，他是把字符串按照指定的分隔符分隔，拆分成数组中的每一项，返回的结果是一个数组"></a>split:和数组中的join方法对应，他是把字符串按照指定的分隔符分隔，拆分成数组中的每一项，返回的结果是一个数组</h5><pre><code>let str=&#39;a|b|c|d&#39;;let result1=str.split(&#39;|&#39;);console.log(result1);// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];let result2=str.split(&#39;&#39;);console.log(result2);// [&quot;a&quot;,&quot;|&quot;,&quot;b&quot;,&quot;|&quot;,&quot;c&quot;,&quot;|&quot;,&quot;d&quot;] &gt;如果为空字符串则将每一个字符分隔，然后组成新的数组let result3=str.split();console.log(result3;//[&quot;a|b|c|d&quot;]&gt; 如果没有任何参数，则直接将其变为数组，值长度为1</code></pre></li></ol></li><li><h4 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h4><ol><li><h5 id="replace-原始字符，新字符-；把字符串中原始字符替换成新字符，在不使用正则的情况下，每次执行replace只能替换为一个"><a href="#replace-原始字符，新字符-；把字符串中原始字符替换成新字符，在不使用正则的情况下，每次执行replace只能替换为一个" class="headerlink" title="replace(原始字符，新字符)；把字符串中原始字符替换成新字符，在不使用正则的情况下，每次执行replace只能替换为一个"></a>replace(原始字符，新字符)；把字符串中原始字符替换成新字符，在不使用正则的情况下，每次执行replace只能替换为一个</h5><pre><code>let str=&#39;Hello world&#39;;console.log(str.replace(&#39;o&#39;,&#39;z&#39;));//&#39;Hellz world&#39;console.log(str.replace(/o/g,&#39;z&#39;));//&#39;Hellz wzrld&#39;</code></pre></li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数组</title>
      <link href="/posts/jsarraystudy/"/>
      <url>/posts/jsarraystudy/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><h2 id="数组是应用数据类型中的对象数据类型-特殊对象"><a href="#数组是应用数据类型中的对象数据类型-特殊对象" class="headerlink" title="数组是应用数据类型中的对象数据类型(特殊对象)"></a>数组是应用数据类型中的对象数据类型(特殊对象)</h2><ol><li><p>创建一个对象也要开辟一个堆内存,堆内存中存储数组对象的键值对</p><pre><code>let arr=[10,20,30];conosle.log(arr);//输出: 0: 10 1: 20    2: 30 length: 3</code></pre></li><li><p>数组中我们看到的每一项都是属性值,默认属性名是数字,数字从零开始递增,数字代表当前的第几项,我们把代表位置的数字属性名称为”索引”;数组是以数字为索引,索引从零开始的结构!</p></li><li><p>在数组中默认存在一个length属性,代表着数组的长度(有多少项)</p><pre><code>let arr=[20,39,54];console.log(arr.length);//3</code></pre></li><li><p>数组中存在的每一项可以是任意数据类型</p><pre><code>let arr=[&#39;aaa&#39;,&#123;name:&#39;teal&#39;&#125;,20,function()&#123;&#125;];console.log(arr);// 输出    0: &quot;aaa&quot;    1: &#123;name: &quot;teal&quot;&#125;    2: 20    3: ƒ ()    length: 4</code></pre></li></ol></li><li><h2 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h2><ul><li>真实项目中,我们把从服务器获取到的数据一般都是对象或者数组(json格式),而且结构层次一般都是多级结构<ol><li>一维数组(只有一级结构)]</li><li>二维数组(也叫多维数组,有两级或以上结构)</li></ol></li></ul></li><li><h2 id="数组中常用的内置方法"><a href="#数组中常用的内置方法" class="headerlink" title="数组中常用的内置方法"></a>数组中常用的内置方法</h2><ol><li><h3 id="关于数组的增删改"><a href="#关于数组的增删改" class="headerlink" title="关于数组的增删改"></a>关于数组的增删改</h3><ul><li><h4 id="push-向数组末尾追加元素"><a href="#push-向数组末尾追加元素" class="headerlink" title="push:向数组末尾追加元素"></a>push:向数组末尾追加元素</h4><ol><li>params: 参数个数不固定,类型也不固定,都是向数组末尾依次追加内容</li><li>return :返回的结构为新增加后数组的长度</li><li>原始数组发生变化</li></ol><pre><code>let arr=[10,20,30];let result=arr.push(40,&#39;50&#39;);console.log(arr);//[10,20,30,40,&#39;50&#39;];console.log(result);//5</code></pre></li><li><h4 id="pop-删除数组中最后一项内容"><a href="#pop-删除数组中最后一项内容" class="headerlink" title="pop:删除数组中最后一项内容"></a>pop:删除数组中最后一项内容</h4><ol><li>params:参数为空</li><li>return:返回结果为删除的内容</li><li>原始数组改变</li></ol><pre><code>let arr=[10,20,30];let result=arr.pop();console.log(arr);//[10,20]console.log(result);//30</code></pre></li><li><h4 id="unshift-向数组开头位置新填内容"><a href="#unshift-向数组开头位置新填内容" class="headerlink" title="unshift:向数组开头位置新填内容"></a>unshift:向数组开头位置新填内容</h4><ol><li>params:参数个数不定,类型不定,都是要依次在数组前新添内容</li><li>return:返回的结果为添加后数组的长度</li><li>原始数组改变</li></ol><pre><code>let arr=[10,20,30];let result=arr.unshift(0,&#39;1&#39;);console.log(arr);//[0,&#39;1&#39;,10,20,30]console.log(result);//5</code></pre></li><li><h4 id="shift-删除数组中第一项内容"><a href="#shift-删除数组中第一项内容" class="headerlink" title="shift:删除数组中第一项内容"></a>shift:删除数组中第一项内容</h4><ol><li>params:参数为空</li><li>return:返回的结果为被删除的内容</li><li>原始数组改变</li></ol><pre><code>let arr=[10,20,30];let result=arr.shift();console.log(arr);//[20,30]console.log(result);//10</code></pre></li></ul></li><li><h3 id="指定位置的增删改"><a href="#指定位置的增删改" class="headerlink" title="指定位置的增删改"></a>指定位置的增删改</h3><ul><li><h4 id="splice-n-m-删除指定位置的内容"><a href="#splice-n-m-删除指定位置的内容" class="headerlink" title="splice(n,m):删除指定位置的内容"></a>splice(n,m):删除指定位置的内容</h4><ol><li>params: 从数组中索引为n的地方开始,删除到m个元素</li><li>return: 返回的结果是删除的内容(以数组类型展示)</li><li>原始数组改变</li></ol><pre><code>let arr=[1,2,3,4,5,6];let result =arr.splice(1,3);console.log(arr);//[1, 5, 6]console.log(result);// [2, 3, 4]</code></pre></li><li><h4 id="splice-n-m-x1-x2-…-修改指定位置数组的内容"><a href="#splice-n-m-x1-x2-…-修改指定位置数组的内容" class="headerlink" title="splice(n,m,x1,x2,…): 修改指定位置数组的内容"></a>splice(n,m,x1,x2,…): 修改指定位置数组的内容</h4><ol><li>params: 从索引n开始,删除m个元素,用x1(或多个值)替换删除后的内容</li><li>return: 返回的一个数组.数组中是删除的内容</li><li>原始值发生变化</li></ol><pre><code>let arr=[1,2,3,4,5];let result=arr.splice(0,2,&#39;1&#39;,2.2);console.log(arr);//[&#39;1&#39;,2.2,3,4,5]console.log(result);//[1,2]</code></pre></li><li><h4 id="splice-n-0-x1-x2-…-在指定的位置添加内容"><a href="#splice-n-0-x1-x2-…-在指定的位置添加内容" class="headerlink" title="splice(n,0,x1,x2,…):在指定的位置添加内容"></a>splice(n,0,x1,x2,…):在指定的位置添加内容</h4><ol><li>params:从索引n开始,一个都不删除,把x1(或更多值)插入到索引n的前面</li><li>返回结果为空数组</li><li>原始数组发生改变</li></ol><pre><code>let arr=[1,2,3,4];let result=arr.splice(1,0,1.1,1.2);console.log(arr);//[1, 1.1, 1.2, 2, 3, 4]console.log(result);// []</code></pre></li><li><h4 id="splice-0-删除数组中所有的内容"><a href="#splice-0-删除数组中所有的内容" class="headerlink" title="splice(0):删除数组中所有的内容"></a>splice(0):删除数组中所有的内容</h4><ol><li>params:从索引0开始,一直删除到数组的末尾</li><li>return:返回值为整个被删除的的数组</li><li>原始数组发生改变</li></ol><pre><code>let arr=[1,2,3,4];let result=arr.splice(0);console.log(arr);//[]console.log(result);//[1,2,3,4]</code></pre></li></ul></li><li><h3 id="关于数组的查询"><a href="#关于数组的查询" class="headerlink" title="关于数组的查询"></a>关于数组的查询</h3><ul><li><h4 id="slice-n-m-实现数组的查询-数组指定位置的截取"><a href="#slice-n-m-实现数组的查询-数组指定位置的截取" class="headerlink" title="slice(n,m):实现数组的查询(数组指定位置的截取)"></a>slice(n,m):实现数组的查询(数组指定位置的截取)</h4><ol><li>params: 从数组n出开始查询,查询到索引为m处(不包含m)</li><li>retutn: 返回的结果以新数组的展示</li><li>原始数组不变</li></ol><pre><code>let arr=[1,2,3,4,5,6];let result=arr.slice(2,4);console.log(arr);//[1,2,3,4,5,6]console.log(result);//[3,4]</code></pre></li><li><h4 id="slice-n-查询指定位置后面所有的内容"><a href="#slice-n-查询指定位置后面所有的内容" class="headerlink" title="slice(n):查询指定位置后面所有的内容"></a>slice(n):查询指定位置后面所有的内容</h4><ol><li>params: 从数组n的位置开始查询,一直查到数组的末尾</li><li>return: 返回的结果是n后面所有的值,并以新数组展示</li><li>原始数组不变</li></ol><pre><code>let arr=[1,2,3,4,5,6];let result=arr.slice(2);console.log(arr);//[1,2,3,4,5,6]console.log(result);//[3,4,5,6]</code></pre></li><li><h4 id="slice-0-查询数组中所有的内容"><a href="#slice-0-查询数组中所有的内容" class="headerlink" title="slice(0):查询数组中所有的内容"></a>slice(0):查询数组中所有的内容</h4><ol><li>params: 从索引0的位置开始截取,一直截取到最后,可以理解为把原始数组中的每一项都查询到</li><li>return : 返回新的数组,实行数组的浅克隆,得到的新数组和原始数组是两个不同的数组(连个不同的堆内存),但是堆内存中存储的内容是一致的</li><li>原始数组不变</li></ol><pre><code>let arr=[1,2,3,4,5];let result=arr.slice(0);console.log(arr);//[1,2,3,4,5]console.log(result);//[1,2,3,4,5]</code></pre></li></ul></li><li><h3 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h3><h4 id="concat-x1-x2-…-实现数组的拼接"><a href="#concat-x1-x2-…-实现数组的拼接" class="headerlink" title="concat(x1,x2,…):实现数组的拼接"></a>concat(x1,x2,…):实现数组的拼接</h4><ol><li>params:把多个数组(或多个值)最后拼接成一个数组</li><li>return: 返回结果为拼接后新的数组</li><li>原始数组不变</li></ol><pre><code>let arr1=[1,2,3];let arr2=[6,7,8];let result=arr1.concat(&#39;4&#39;,5,arr2);console.log(arr1);//[1,2,3]console.log(arr2);//[6,7,8]console.log(result);//[1,2,3,&#39;4&#39;,5,6,7,8]</code></pre></li><li><h3 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h3><ul><li><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString();"></a>toString();</h4><ol><li>params:把数组中的每一项按照”逗号分隔”,拼接成对应的字符串</li><li>原始数组不改变</li></ol><pre><code>let arr=[10,20,30];console.log(arr.toString());//&quot;10,20,30&quot;</code></pre></li><li><h4 id="join-char"><a href="#join-char" class="headerlink" title="join([char]);"></a>join([char]);</h4><ol><li><p>char:以指定的字符分隔成对应的字符串</p></li><li><p>原始数组不改变</p><pre><code>let arr=[10,20,30,40];console.log(arr.join(&#39;&#39;));//&#39;10203040&#39; =&gt;以空格分隔数组</code></pre></li></ol></li></ul></li><li><h3 id="获取数组中指定的索引"><a href="#获取数组中指定的索引" class="headerlink" title="获取数组中指定的索引"></a>获取数组中指定的索引</h3><ul><li><h4 id="indexOf-value-获取当前项在数组中第一次"><a href="#indexOf-value-获取当前项在数组中第一次" class="headerlink" title="indexOf([value]);获取当前项在数组中第一次"></a>indexOf([value]);获取当前项在数组中第一次</h4><ol><li>params:获取指定位置的索引</li><li>return:返回结果为出现位置的索引,不存在返回-1</li><li>原始数组不变</li></ol><pre><code>let arr=[10,20,30,40,50];let result1=arr.indexOf(30);let result2=arr.indexOf(60);console.log(arr);//[10,20,30,40,50]console.log(result1);//2console.log(result2);//-1</code></pre></li><li><h4 id="lastIndexOf-value-获取最后出现的索引"><a href="#lastIndexOf-value-获取最后出现的索引" class="headerlink" title="lastIndexOf([value]);获取最后出现的索引"></a>lastIndexOf([value]);获取最后出现的索引</h4><ol><li>params: 获取指定位置的索引</li><li>return: 返回最后一次出现位置的索引,如果不存在返回-1</li><li>原始数组不变</li></ol><pre><code>let arr=[1,2,3,4,3,4,3];let result1=arr.lastIndexOf(3);let result2=arr.lastIndexOf(5);console.log(arr);//[1,2,3,4,3,4,3]console.log(result1);//6console.log(result2);//-1</code></pre></li><li><h4 id="includes-value-验证数组中是否包含指定内容"><a href="#includes-value-验证数组中是否包含指定内容" class="headerlink" title="includes([value]):验证数组中是否包含指定内容"></a>includes([value]):验证数组中是否包含指定内容</h4><ol><li>params:指定的内容</li><li>return: 返回结果存在返回true,不存在返回false</li><li>原始数组不改变</li></ol><pre><code>let arr=[1,2,3,4,5];console.log(arr.includes(2));//trueconsole.log(arr.includes(6));//false</code></pre></li></ul></li><li><h3 id="反转与排序"><a href="#反转与排序" class="headerlink" title="反转与排序"></a>反转与排序</h3><ul><li><h4 id="reverse-数组反转"><a href="#reverse-数组反转" class="headerlink" title="reverse(); 数组反转"></a>reverse(); 数组反转</h4><ol><li>params:无参数</li><li>return:返回的结果是排列后原始的数组,原始数组改变(因反转后原始数组===排列后的数组,所以一般不需要返回值,直接输出原始值即可)</li><li>原始数组改变</li></ol><pre><code>let arr=[1,2,3,4,5];console.log(arr.reverse());//[5,4,3,2,1]</code></pre></li><li><h4 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort; 数组排序"></a>sort; 数组排序</h4><ol><li>param:回调函数</li><li>return: 返回把原始数组按照规则进行排序后的值</li><li>原始数组会发生改变</li></ol><pre><code>let arr=[2,4,5,1,3];console.log(arr.sort());//[1,2,3,4,5]</code></pre><ul><li>sort可以对单位数进行有效排序</li><li>sort支持传递回调函数,基于自定义排序规则</li><li>sort(a,b):在回调函数中,有两个形参.可以进行排序(返回a-b可以得到升序结果,b-a可以得到降序结果)</li></ul><pre><code>let arr1=[3,2,4,1,6,5];let arr2=[3,2,4,1,6,5];let result1 =arr1.sort(function(a,b)&#123;    return a-b;&#125;);let result2 =arr2.sort(function(a,b)&#123;    return b-a;&#125;);console.log(result1);//[1,2,3,4,5,6]console.log(result2);//[6,5,4,3,2,1]</code></pre></li></ul></li><li><h3 id="数组中常用的迭代方法-遍历数组中的每一项"><a href="#数组中常用的迭代方法-遍历数组中的每一项" class="headerlink" title="数组中常用的迭代方法(遍历数组中的每一项)"></a>数组中常用的迭代方法(遍历数组中的每一项)</h3><ul><li><h4 id="forEach-函数-遍历数组中的每一项-数组中有多少项-函数会相继执被执行多少次-每一次执行函数-都可以在函数中获取当前的遍历的这一项个对应的索引"><a href="#forEach-函数-遍历数组中的每一项-数组中有多少项-函数会相继执被执行多少次-每一次执行函数-都可以在函数中获取当前的遍历的这一项个对应的索引" class="headerlink" title="forEach([函数]);遍历数组中的每一项(数组中有多少项,函数会相继执被执行多少次),每一次执行函数,都可以在函数中获取当前的遍历的这一项个对应的索引"></a>forEach([函数]);遍历数组中的每一项(数组中有多少项,函数会相继执被执行多少次),每一次执行函数,都可以在函数中获取当前的遍历的这一项个对应的索引</h4><ol><li>forEach中有一个回调函数,形参为item,index</li><li>item:表示当前项的内容</li><li>index:表示当前项的索引</li></ol><pre><code>let arr=[1,2,3];arr.forEach(function(item,index)&#123;    console.log(item);// 1 &gt; 2 &gt; 3    console.log(index);// 0 &gt; 1 &gt; 2&#125;);</code></pre></li><li><h4 id="map-forEach是不支持返回值的-而map可以在forEach的基础上支持返回值-把原来数组中每一项的值替换为新值-最后存储在一个新的数组中-但原始数组不变"><a href="#map-forEach是不支持返回值的-而map可以在forEach的基础上支持返回值-把原来数组中每一项的值替换为新值-最后存储在一个新的数组中-但原始数组不变" class="headerlink" title="map:forEach是不支持返回值的,而map可以在forEach的基础上支持返回值,把原来数组中每一项的值替换为新值,最后存储在一个新的数组中,但原始数组不变"></a>map:forEach是不支持返回值的,而map可以在forEach的基础上支持返回值,把原来数组中每一项的值替换为新值,最后存储在一个新的数组中,但原始数组不变</h4><ol><li>map支持返回值但是不会改变原来的数组,执行完的返回结果是修改后的新数组</li><li>map中有一个回调函数,函数中有两个形参item,index</li><li>item:当前循环的这一项的值</li><li>index:当前值的对应的索引</li><li>函数返回啥都是把数组中当前项替换成啥,但原始数组不变</li></ol><pre><code>let arr=[1,2,3,4];let result= arr.map(function(item,index)&#123;    return item*10;&#125;);console.log(result);//[10,20,30,40]</code></pre></li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数学函数中的常用方法</title>
      <link href="/posts/jsmathstudy/"/>
      <url>/posts/jsmathstudy/</url>
      
        <content type="html"><![CDATA[<blockquote><h6 id="math是一个对象数据类型值-在他的堆内存中-存储了很多内置属性及方法-这些方法-一般都是直接用来操作的数字的-所以我们把Math”数字函数对象”"><a href="#math是一个对象数据类型值-在他的堆内存中-存储了很多内置属性及方法-这些方法-一般都是直接用来操作的数字的-所以我们把Math”数字函数对象”" class="headerlink" title="math是一个对象数据类型值,在他的堆内存中,存储了很多内置属性及方法,这些方法,一般都是直接用来操作的数字的,所以我们把Math”数字函数对象”"></a>math是一个对象数据类型值,在他的堆内存中,存储了很多内置属性及方法,这些方法,一般都是直接用来操作的数字的,所以我们把Math”数字函数对象”</h6></blockquote><h3 id="Math内置的方法"><a href="#Math内置的方法" class="headerlink" title="Math内置的方法"></a>Math内置的方法</h3><ul><li><h4 id="Math-PI-Math-‘PI’-获取圆周率"><a href="#Math-PI-Math-‘PI’-获取圆周率" class="headerlink" title="Math.PI / Math[‘PI’] :获取圆周率"></a>Math.PI / Math[‘PI’] :获取圆周率</h4><pre><code>console.log(Math.PI);//3.141592653589793</code></pre></li><li><h4 id="Mth-abs-n-获取数字n的绝对值-绝对值都是正数"><a href="#Mth-abs-n-获取数字n的绝对值-绝对值都是正数" class="headerlink" title="Mth.abs([n]);获取数字n的绝对值(绝对值都是正数)"></a>Mth.abs([n]);获取数字n的绝对值(绝对值都是正数)</h4><pre><code>console.log(Math.abs(-23));//23console.log(Math.abs(23));//23console.log(Math.abs(0));//0</code></pre></li><li><h4 id="Math-ceil-n-Math-floor-n-把数字N向上或向下取整"><a href="#Math-ceil-n-Math-floor-n-把数字N向上或向下取整" class="headerlink" title="Math.ceil([n]) / Math.floor([n])把数字N向上或向下取整"></a>Math.ceil([n]) / Math.floor([n])把数字N向上或向下取整</h4><pre><code>console.log(Math.ceil(12.10));//13console.log(Math.ceil(12.99));//13console.log(Math.floor(12.01));//12console.log(Math.floor(12.99));//12</code></pre></li><li><h4 id="Math-round-n-把数字N四舍五入-结果都是整数"><a href="#Math-round-n-把数字N四舍五入-结果都是整数" class="headerlink" title="Math.round([n]);把数字N四舍五入(结果都是整数)"></a>Math.round([n]);把数字N四舍五入(结果都是整数)</h4><pre><code>console.log(Math.round(12.49));//12console.log(Math.round(12.99));//13</code></pre></li><li><h4 id="Math-sqrt-n-给数字N开平方"><a href="#Math-sqrt-n-给数字N开平方" class="headerlink" title="Math.sqrt([n]);给数字N开平方"></a>Math.sqrt([n]);给数字N开平方</h4><pre><code>console.log(Math.sqrt(4));//2console.log(Math.sqrt(16));//4console.log(Math.sqrt(10));//3.1622776601683795</code></pre></li><li><h4 id="Math-random-获取0-1之间的随即小数"><a href="#Math-random-获取0-1之间的随即小数" class="headerlink" title="Math.random();获取0-1之间的随即小数"></a>Math.random();获取0-1之间的随即小数</h4><pre><code>console.log(Math.random());//随机小数(大概率不会一样)</code></pre><ul><li><h4 id="获取-n-m-之间的随机整数-包含n和m"><a href="#获取-n-m-之间的随机整数-包含n和m" class="headerlink" title="获取[n,m]之间的随机整数(包含n和m);"></a>获取[n,m]之间的随机整数(包含n和m);</h4><ul><li>公式为:Math.round(Math.random()*(m-n)+n)</li></ul></li></ul><pre><code>function rundomNum(n,m)&#123;    return Math.round(Math.random()*(m-n)+n);&#125;;let result=rundomNum(0,10);console.log(result);//结果为0-10之间的随机整数</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中arguments使用</title>
      <link href="/posts/jsarguments/"/>
      <url>/posts/jsarguments/</url>
      
        <content type="html"><![CDATA[<blockquote><p>arguments函数内置的实参集合，不管我们设置形参与否，再或者是否传递了实参，arguments始终都会存在（ES6箭头函数中没有arguments），arguments只能出现在函数体中</p></blockquote><blockquote><p>在ES6中可以使用剩余运算符来获取传递的实参</p></blockquote><blockquote><p>arguments是一个伪数组（类似于数组，但不是数组，个元素集合HTMLCollection类似）</p></blockquote><blockquote><p>arguments根据索引记录了每一个传递进来的实参信息（和是否定义形参变量没有关系），arguments中包含了所有传递进来的实参信息）</p></blockquote><blockquote><p>arguments中length属性代表了传递实参的个数</p></blockquote><p>==========================================================================</p><blockquote><p>练习 输出所有形参和的值，非法数字不进行计算</p><pre><code>function sum() &#123;   let total = 0;//创建一个变量定义初始值   for (var i = 0; i &lt; arguments.length; i++) &#123;       let item =arguments[i]-0;//将循环中每一项的值转换为字符串(-0相当于Number())       if (!isNaN(item)) &#123; // 判断不是NaN的值           total += item;  //将每次循环得到的有效数字累加到total中       &#125;;   &#125;;   console.log(total);// =&gt;100&#125;;sum(10,&#39;70&#39;, 20,&#39;fdsa&#39;);//调用计算函数，传递形参</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型对比转换</title>
      <link href="/posts/jsimplicit/"/>
      <url>/posts/jsimplicit/</url>
      
        <content type="html"><![CDATA[<ol><li><p>特殊类型对比</p><ul><li>NaN==NaN; // =&gt;false  NaN和任何数比较都是false包括自己本省</li><li>Infinity==Infinity; // =&gt;true   Infinity只有各自己比较为true，其余都为false</li><li>symbol(1)==symbol(1);  // =&gt;false   symbol和任何数相比都为false</li><li>null==undefined; // =&gt;true   null和undefined两个等号相比为true，三个等号为false，除此之外与其他类型相比都为false</li></ul></li><li><p>隐式转换规则</p><ul><li>对象==字符串  对象转换为字符串然后在进行比较</li><li>除以上规则外其余的都是把值转换为数字类型，然后在进行比较</li></ul></li><li><p>练习</p><pre><code>console.log([10]==&#39;10&#39;);// =&gt; 10==10 &gt; trueconsole.log(&#123;&#125;==&#39;&#123;&#125;&#39;);// =&gt; &quot;object&quot;==&#39;&#123;&#125;&#39; &gt; falseconsole.log(1==true);// =&gt;1==1 &gt; trueconsole.log(2==true);// 2==1 &gt; falseconsole.log(-1==false);// =&gt; -1==0 &gt; falseconsole.log(0==false);// =&gt;0==0 &gt; trueconsole.log(1==&#39;1&#39;);// =&gt; 1==1 &gt; trueconsole.log(true==&#39;1&#39;);// =&gt; 1==1 &gt; trueconsole.log(false==&quot;&quot;);// =&gt; 0==0 &gt;trueconsole.log([]==0);// =&gt; 0==0 &gt; true</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的循环</title>
      <link href="/posts/jsloop/"/>
      <url>/posts/jsloop/</url>
      
        <content type="html"><![CDATA[<h1 id="js中的循环"><a href="#js中的循环" class="headerlink" title="js中的循环"></a>js中的循环</h1><ol><li><p>for循环  =&gt;循环数组</p><ul><li><p>循环：一轮一轮的重复做某一件事情（真是项目中一般都控制相关的事情执行一遍）</p></li><li><p>使用：for(设置初始值；设置循环条件，控制循环次数；每一轮循环结束购处理的事情[步长累加])</p></li><li><p>循环体</p><ol><li>设置初始值</li><li>验证条件（条件不成立循环体结束）</li><li>循环体</li><li>步长累加</li><li>再次验证</li><li>循环体</li><li>一直重复执行，一直到验证条件不成立为止</li></ol></li><li><p>循环体可能出现的两个关键词</p><ol><li><p>break:强制结束整个循环，所有在循环体中的代码都不在执行</p><pre><code>for(var=0;i&lt;5;i++)&#123;    console.log(i);// =&gt;0    break;// 结束整个循环&#125;console.log(i);// =&gt;0</code></pre></li><li><p>continue:结束本轮循环体，下一轮继续执行，但当前循环体中continue下面的代码不在执行</p><pre><code>for(var i=0;i&lt;5;i++)&#123;    if(i==0)&#123;        continue;    &#125;    console.log(i); // =&gt; 1 &gt; 2 &gt; 3 &gt; 4&#125;;console.log(i);// =&gt;5</code></pre></li></ol></li><li><p>遍历（循环/迭代）数组中的每一项：因为数组有索引个length属性，所以我们能够知道循环次数，也能基于索引获取对应项，使用for循环就可以解决</p><pre><code>let arr=[10,20,30];for(var i=0;i&lt;arr.length;i++)&#123;    console.log(arr[i]);// =&gt; 10 &gt; 20 &gt; 30&#125;;</code></pre></li></ul></li><li><p>for in循环  =&gt;循环对象</p><blockquote><p>遍历对象中的每一个属性：我们无法直接获取到对象中有多少个属性，也就无法知道循环多少次，所以无法使用for循环，真实项目中遍历对象我们基于的是for in循环</p></blockquote><ul><li><p>使用：创建变量（存储的是属性） in 对象</p></li><li><p>当前对象中有多少可枚举的属性，就循环多少次</p></li><li><p>key 变量存储的是每一次循环的属性名</p></li><li><p>obj[key] 获取key变量中的对象属性名的属性值</p><pre><code>var obj=&#123;    name:&#39;teal&#39;,    age:20,    skill:&#39;睡觉&#39;&#125;;for(var key in obj)&#123;    consoel.log(key);// =&gt;&quot;name&quot; &gt; &quot;age&quot; &gt; &quot;skill&quot;    console.log(obj[key]);// &#39;teal&#39; &gt; 20 &gt; &#39;睡觉&#39;&#125;</code></pre><blockquote><p>for in遍历对象的时候，是按照从小到大的机制遍历数字属性的</p><pre><code>var obj=&#123;   name:&#39;teal&#39;,   age:20,   1:12,   5:30&#125;for(var key in obj)&#123;   console.log(key); // =&gt; &quot;1&quot; &gt; &quot;2&quot; &gt; &quot;name&quot; &gt; &quot;age&quot;   console.log(obj[key]); // =&gt; 12 &gt; 30 &gt; &#39;teal&#39; &gt; 20&#125;</code></pre></blockquote></li></ul></li><li><p>练习</p><pre><code>for (var i=0;i&lt;5;i++)&#123;    console.log(i); // =&gt; 0 &gt; 1 &gt;2 &gt;3 &gt;4    continue;&#125;console.log(i);// =&gt;5</code></pre><pre><code>for(var i=0;i&lt;5;i++)&#123;    continue;    console.log(i);// =&gt;应continue会结束本此循环项，所以以下代码不会执行&#125;;console.log(i); // =&gt;5</code></pre><pre><code>for(var i=1;i&lt;=10;i+=2)&#123; // =&gt;2+2 &gt;5+2 &gt;    if(i&lt;=5)&#123;        i++; // =&gt;1+1 &gt; 4+1         continue; // =&gt; 结束本次循环    &#125;else&#123;        i+=2;// =&gt;7+2        break;// =&gt;结束整个循环    &#125;;    i--;// 因上面个判断条件中有结束循环语句，所以不可能执行以下代码    console.log(i);&#125;;console.log(i);// =&gt;9</code></pre><pre><code>for(var i=3;i&lt;12;i++)&#123;    if(i&lt;3)&#123;        i++;        break;    &#125;;    if(i&gt;9)&#123;        i+=2;        continue;    &#125;;    i--;&#125;;console.log(i)//;//解析：以上代码为死循环，1、循环过程首先判断i(3)小于12吗，条件成立.2、进入循环项，判断i(3)小于3吗，条件不成立，集训执行下面代码，判断i(3)大于9吗，条件不成立，继续执行下面代码，让i--(3-1)。本次循环结束，执行i++(2+1)，继续判断i(3)小于12，成立进入循环项，继续判断，就这样一直进入了死循环</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中ruturn的使用</title>
      <link href="/posts/jsreturn/"/>
      <url>/posts/jsreturn/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当函数执行的时候，会形成一个全新的执行上下文，函数体中的代码在这个上下文中云运行，代码在运行中，会把所有创建的变量存储到当前上下文的AO(活动变量对象)中，这些变量是“私有变量”，除了当前上下文中可以使用这些变量的值，上下文以外的环境不能使用私有变量的值，如果外面想用当前上下文中的一些信息，则需要函数对外提供的出口，把信息提供给外面使用，而这个出口在js函数中被称为“返回值”</p><p>return返回的一定是值</p><pre><code>function fun()&#123;   return 20+10;&#125;let num=fun();console.log(num);//30</code></pre><p>如果函数中没写return，默认返回的值是undefined</p><pre><code>function fun()&#123;   let num=20;&#125;;let num=fun();console.log(num);//undefined</code></pre><p>return 在函数中除了返回信息外，还有结束函数中代码的代码，不在向下执行的作用</p><pre><code>function fun()&#123;   let a=1;   return;   console.log(a);//没有任何输出&#125;;fun();</code></pre></blockquote><p>==============================================================================</p><blockquote><p>for循环中结束整个循环用break</p><p>for循环中结束当前循环项用continue</p><p>switch case中结束判断语句用break</p><p>函数中结束函数用return</p><p>在函数中，判断和循环可以结合return一起使用，结束了函数结束相当于结束了函数中循环个判断语句，但在函数以外不能在一起混用，否则会报错</p><pre><code>for(var i=0;i&lt;20;i++)&#123;   if(i&gt;=10)&#123;       return   &#125;;   console.log(i);// Uncaught SyntaxError: Illegal return statement&#125;</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一部分学习总结</title>
      <link href="/posts/jssummary1/"/>
      <url>/posts/jssummary1/</url>
      
        <content type="html"><![CDATA[<h1 id="学习第一部分总结"><a href="#学习第一部分总结" class="headerlink" title="学习第一部分总结"></a>学习第一部分总结</h1><ol><li><h2 id="前端的发展史"><a href="#前端的发展史" class="headerlink" title="前端的发展史"></a>前端的发展史</h2><ul><li><h3 id="了解重要的历史节点"><a href="#了解重要的历史节点" class="headerlink" title="了解重要的历史节点"></a>了解重要的历史节点</h3></li><li><h3 id="重点掌握WEB1-0-WEB3-0的进化史"><a href="#重点掌握WEB1-0-WEB3-0的进化史" class="headerlink" title="重点掌握WEB1.0~WEB3.0的进化史"></a>重点掌握WEB1.0~WEB3.0的进化史</h3><ul><li>动态页面</li><li>前后端分离</li><li>WebApp(NativeApp)</li><li>全栈开发</li><li>……</li></ul></li></ul></li><li><h2 id="浏览器常用的内核"><a href="#浏览器常用的内核" class="headerlink" title="浏览器常用的内核"></a>浏览器常用的内核</h2><ul><li>Webkit</li><li>Gecko</li><li>Trident</li><li>Blink</li><li>…..</li></ul></li><li><h2 id="js三部分"><a href="#js三部分" class="headerlink" title="js三部分"></a>js三部分</h2><ul><li>ECMAscript</li><li>DOM</li><li>BOM</li></ul></li><li><h2 id="变量个变量定义"><a href="#变量个变量定义" class="headerlink" title="变量个变量定义"></a>变量个变量定义</h2><ul><li><h3 id="变量就是起了一个名字，用来存储-指向-或者代表某一个值得-他是一个虚拟的东西，值才是实在的东西"><a href="#变量就是起了一个名字，用来存储-指向-或者代表某一个值得-他是一个虚拟的东西，值才是实在的东西" class="headerlink" title="变量就是起了一个名字，用来存储(指向)或者代表某一个值得(他是一个虚拟的东西，值才是实在的东西)"></a>变量就是起了一个名字，用来存储(指向)或者代表某一个值得(他是一个虚拟的东西，值才是实在的东西)</h3></li><li><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>严格区分大小写</li><li>驼峰命名法</li><li>基于”_、$、数字、字母”命名，但数字不能作为开头</li><li>不能使用关键字及保留字</li></ul></li><li><h3 id="定义变量的几种方式"><a href="#定义变量的几种方式" class="headerlink" title="定义变量的几种方式"></a>定义变量的几种方式</h3><ul><li>var</li><li>let </li><li>const =&gt;定义的变量，变量指向不能随意被更改（理解为定义的是一个常量）</li><li>function</li><li>class</li><li>import</li></ul></li></ul></li><li><h2 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型**"></a>js中的数据类型**</h2><ul><li><h3 id="基本数据类型（值类型-原始值）"><a href="#基本数据类型（值类型-原始值）" class="headerlink" title="基本数据类型（值类型 / 原始值）"></a>基本数据类型（值类型 / 原始值）</h3><ul><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li><li>symbol</li><li>bigint</li></ul></li><li><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul><li><h4 id="对象数据类型"><a href="#对象数据类型" class="headerlink" title="对象数据类型"></a>对象数据类型</h4><ul><li>{} 普通对象</li><li>[] 数组对象</li><li>/^$/ 正则对象</li><li>日期对象</li><li>Math数学对象</li><li>……</li></ul></li><li><p>函数数据类型</p></li></ul></li></ul></li><li><h2 id="数据类型的检测"><a href="#数据类型的检测" class="headerlink" title="数据类型的检测**"></a>数据类型的检测**</h2><ul><li><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>语法 =&gt; typeof[value]</li><li>返回值首先是字符串其次包含对应的类型 =&gt;typeof typeof [] ===”string”</li><li>typeof null === “object”</li><li>数组、正则、普通对象最后检测出的结果都是”object”,所以基于此操作，无法细分对象</li></ul></li><li><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3></li><li><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3></li><li><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3></li></ul></li><li><h2 id="数字类型详解"><a href="#数字类型详解" class="headerlink" title="数字类型详解**"></a>数字类型详解**</h2><ul><li><h3 id="NaN-和-isNaN"><a href="#NaN-和-isNaN" class="headerlink" title="NaN 和 isNaN"></a>NaN 和 isNaN</h3><ul><li>typeof NaN===”number”</li><li>NaN !==NaN</li><li>基于isNaN检测值是否为有效数字（检测的值不是数字类型，需要默认基于Number()把其转换为数字类型，然后在检测）</li></ul></li><li><h3 id="把其他类型的值转换为数字类型"><a href="#把其他类型的值转换为数字类型" class="headerlink" title="把其他类型的值转换为数字类型"></a>把其他类型的值转换为数字类型</h3><ul><li><h4 id="Number-value"><a href="#Number-value" class="headerlink" title="Number([value])"></a>Number([value])</h4><ul><li>字符串转换为数字：字符串是0，字符串中只要出现任意一个非有效数字字符，结果都为NaN</li><li>布尔转换为数字：true是1   false是0</li><li>undfined转换为数字：NaN</li><li>symbol不能转换为数字：否则会报错</li><li>对象(或者函数)转换为数字，首先都是调用toString先转换为字符串，然后在转换为数字<ul><li>普通对象转换为字符串结果是：”[object object]”</li><li>数组转换为字符串结果是：用逗号分隔数组中的每一项<ul><li>[]  =&gt;” “</li><li>[10] =&gt;”10”</li><li>[10,20] =&gt;”10,20”</li></ul></li><li>正则或者函数转换为字符串和原始看的内容类似</li></ul></li></ul></li><li><h3 id="parseInt-value-parseFloat-value"><a href="#parseInt-value-parseFloat-value" class="headerlink" title="parseInt([value])/parseFloat([value])"></a>parseInt([value])/parseFloat([value])</h3><ul><li>首先把[value]值变为字符串，其次从字符串最左侧开始找，把找到的有效数字字符串转换为数字，遇到一个非有效数字的字符串则结束查找（不论左侧是否还有没有数字，都不在查找了）</li><li>Number(true) =&gt;1</li><li>parseint(true) =&gt;NaN</li><li>Number(‘12px’) =&gt;NaN</li><li>parseInt(‘12px’) =&gt;12</li></ul></li><li><h3 id="一些常用的属性方法"><a href="#一些常用的属性方法" class="headerlink" title="一些常用的属性方法"></a>一些常用的属性方法</h3><ul><li>数字.toFixed(N)  保留小数点N位，返回的结果是一个字符串</li></ul></li></ul></li><li><p>Infinity 无穷大</p><ul><li>……</li></ul></li></ul></li><li><h2 id="字符串类型详解"><a href="#字符串类型详解" class="headerlink" title="字符串类型详解**"></a>字符串类型详解**</h2><ul><li><h3 id="把其他类型转换为字符串"><a href="#把其他类型转换为字符串" class="headerlink" title="把其他类型转换为字符串"></a>把其他类型转换为字符串</h3><ul><li>string([value])</li><li>[value].toString()</li></ul></li><li><h3 id="加号在js中除了数学运算，还有字符串拼接"><a href="#加号在js中除了数学运算，还有字符串拼接" class="headerlink" title="加号在js中除了数学运算，还有字符串拼接"></a>加号在js中除了数学运算，还有字符串拼接</h3><ul><li><p>减乘除和取余都一定是数学运算（不是数学类型要转换为数字类型，然后在运算）</p></li><li><p>加号两边的任意一边出现字符串，则为字符串拼接（如果加的是一个对象，其实最后也是字符串拼接，因为对象转换为数字，是转换为字符串的）</p><ul><li>1+’1’===’11’</li><li>1+[10]===’101’</li></ul></li><li><p>基于ES6的模板字符串（反引号 或者叫两个撇）可以方便字符串的拼接</p><pre><code>//$&#123;&#125;就是把一个变量的值或者一个js表达式运行的结果，拼接到模板字符串中let n=10;let str=`N的值是：$&#123;n&#125;`;console.log(str);// =&gt;&quot;N的值是：10&quot;</code></pre></li></ul></li></ul></li><li><h2 id="布尔类型详解"><a href="#布尔类型详解" class="headerlink" title="布尔类型详解**"></a>布尔类型详解**</h2><ul><li><h3 id="把其他数据类型转换为布尔类型"><a href="#把其他数据类型转换为布尔类型" class="headerlink" title="把其他数据类型转换为布尔类型"></a>把其他数据类型转换为布尔类型</h3><ul><li><p>规律：只有 “0、NaN、null、undefined、空字符串”五个值最后变为FALSE,其余都会转换为TRUE</p></li><li><p>Boolean([value])</p></li><li><p>![value]转换为布尔再取反</p></li><li><p>!![value] 转换为布尔</p></li></ul><hr><ul><li><p>在条件判断中，最后的结果都是转换为布尔</p></li><li><p>……</p></li></ul></li></ul></li><li><h2 id="对象数据类型详解"><a href="#对象数据类型详解" class="headerlink" title="对象数据类型详解**"></a>对象数据类型详解**</h2><ul><li><h3 id="对象的组成：零到多组键值对组成（key-value-gt-属性名：属性值），每一组之间用逗号分隔"><a href="#对象的组成：零到多组键值对组成（key-value-gt-属性名：属性值），每一组之间用逗号分隔" class="headerlink" title="对象的组成：零到多组键值对组成（key:value =&gt; 属性名：属性值），每一组之间用逗号分隔"></a>对象的组成：零到多组键值对组成（key:value =&gt; 属性名：属性值），每一组之间用逗号分隔</h3></li><li><h3 id="关于对象键值对的操作（增删改查）"><a href="#关于对象键值对的操作（增删改查）" class="headerlink" title="关于对象键值对的操作（增删改查）"></a>关于对象键值对的操作（增删改查）</h3><ul><li><p>对象的属性名不能重复</p></li><li><p>对象.属性名  =&gt;这样的操作属性名不能为数字</p></li><li><p>对象[属性名]  =&gt;obj[‘n’]和obj[n]是不一样的，前者属性名就是n,后者是吧n变量存储的值作为属性名拿过来操作的</p><pre><code>let n=13;let obj=&#123;    n:20;&#125;;obj[&#39;n&#39;]=30;console.log(obj);// =&gt;&#123;n:30&#125;obj[n]=10;// 相当于obj[13]=10console.log(obj);// =&gt;&#123;n:30,&quot;13&quot;:10&#125;</code></pre></li></ul></li></ul></li><li><h2 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别 ***"></a>基本数据类型和引用数据类型的区别 ***</h2><ul><li><p>堆内存（HEAP）和栈内存（STACK）</p></li><li><p>栈内存</p><p>ESCtack 执行环境栈</p><p>EC(G) 全局执行上下文</p><p>VO(G) 全局变量对象</p><p>let a=12</p><ul><li>创建12这个值，存放到栈内存中（栈内存是用来执行代码和存储基本数据类型的）</li><li>创建变量a存储到VO(G)</li><li>最后让a指向12这个值 （赋值的意思 =&gt;值得指向）</li></ul></li><li><p>堆内存</p><ul><li>let obj ={xxx:”xxx”}<ul><li>创建对象值（引用数据类型不能直接存储到栈内存中）<ul><li>创建一个堆内存，有一个16进制地址（如：AAAFFF000）</li><li>把对象中的键值对存储到堆中</li><li>把堆内存得地址存放到栈内存中，供变量指向</li></ul></li><li>后期obj.xxx得所有操作，都是基于地址找到对内存，从而来操作堆内存中的内容</li></ul></li></ul></li></ul></li><li><h2 id="DOM的一些操作"><a href="#DOM的一些操作" class="headerlink" title="DOM的一些操作"></a>DOM的一些操作</h2><ul><li>document.getElementById</li><li>document.body<ul><li>js中获取的元素都是对象数据类型的（有自己对应的堆内存，堆内存中存储者很对内置的属性和方法，这些属性方法就是操作DOM元素的）<ul><li>id</li><li>className</li><li>tagName</li><li>innerHTML</li><li>innerText</li><li>style =对象   操作当前的元素的”行内样式“</li><li>onclick</li><li>……</li></ul></li><li>context.getElementsByTagName<ul><li>获取到的是一个伪数组(类数组)元素集合 HTMLCollection</li><li>操作起来和数组类似（基于索引获取到某一项以及循环操作等）</li></ul></li></ul></li></ul></li><li><h2 id="js中常用的操作语句"><a href="#js中常用的操作语句" class="headerlink" title="js中常用的操作语句**"></a>js中常用的操作语句**</h2><ul><li>判断语句<ul><li>if 、else、if、else</li><li>三元运算符<ul><li>语法  ：条件？成立：不成立</li><li>基于null/undefined占位</li><li>多个事情基于括号包起来、逗号分隔</li><li>三元嵌套</li></ul></li><li>switch case<ul><li>每一种 case都是===判断</li><li>== 和===的区别</li></ul></li><li>循环语句<ul><li>for循环：指定循环的次数或者遍历数组<ul><li>四部操作</li><li>break</li><li>continue</li></ul></li><li>for in 循环：变量对象中的键值对的<ul><li>优先按照从小到大遍历数字属性</li></ul></li><li>……</li></ul></li></ul></li></ul></li><li><h2 id="js中常用的输出方式"><a href="#js中常用的输出方式" class="headerlink" title="js中常用的输出方式"></a>js中常用的输出方式</h2><ul><li>console<ul><li>.log</li><li>.dir</li><li>.table</li><li>.time   /  .timeEnd</li><li>.wran</li><li>….</li></ul></li><li>浏览器弹出窗口（输出的结果都会变为字符串）<ul><li>alert</li><li>confirm</li><li>prompt</li></ul></li><li>向页面中输出内容（输出的结果都会变为字符串）<ul><li>document.write</li><li>元素.innerHTML</li><li>元素.innerText</li><li>……</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的判断方法</title>
      <link href="/posts/jsjudge/"/>
      <url>/posts/jsjudge/</url>
      
        <content type="html"><![CDATA[<h1 id="js中的判断方式"><a href="#js中的判断方式" class="headerlink" title="js中的判断方式"></a>js中的判断方式</h1><ul><li><p>if…else…else if….else这种方式进行判断</p><pre><code>let a=10;if(a&gt;10)&#123;    console.log(a++)&#125;else if(a&lt;10)&#123;    console.log(a--)&#125;else&#123;    consolelog(20) //20&#125;</code></pre></li><li><p>三元运算符判断</p><blockquote><p>格式：条件表达式？成立所做的事情：失败所做的事情</p></blockquote><pre><code>let a=10;a&gt;10?a++:a--;console.log(a);//9</code></pre><blockquote><p>复杂数据三元表达式判断，可以用括号包起来，让后以逗号分隔</p></blockquote><pre><code>let a=10;a&gt;10?(a++,console.log(a)):(null,console.log(a));//10</code></pre></li><li><p>switch case 判断</p><pre><code>let a=10;switch(a)&#123; // 表达式    case 5: //case表示条件分支 ，只有两个数全等的情况才会执行里面的代码    consoel.log(5);    break; //如果条件成立以下代码不在执行    case 10:    console.log(10); // 10    break;    default:// default 表示没有符合条件的时候    console.log(30)&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 判断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈内存与堆内存</title>
      <link href="/posts/jsstack/"/>
      <url>/posts/jsstack/</url>
      
        <content type="html"><![CDATA[<h1 id="栈内存与堆内存"><a href="#栈内存与堆内存" class="headerlink" title="栈内存与堆内存"></a>栈内存与堆内存</h1><h2 id="内存分类"><a href="#内存分类" class="headerlink" title="内存分类"></a>内存分类</h2><ul><li>栈内存  stack</li><li>堆内存  heap </li></ul><h2 id="栈内存与堆内存区别"><a href="#栈内存与堆内存区别" class="headerlink" title="栈内存与堆内存区别"></a>栈内存与堆内存区别</h2><ol><li>栈内存是储存基本数据类型值和为执行上下文提供的环境</li><li>堆内存是存储引用数据类型的，他会在内存中开辟一条新的内存来储存值，并生成一个16进制的地址</li></ol><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h2><ul><li><p>当当浏览器中打开页面，浏览器引擎会渲染相关的代码（包含js代码），换句话说就是把代码从上往下执行</p></li><li><p>浏览器想要执行代码，会提供一个代码执行环境，(ECStack 全称 Execution Context Stack  =&gt;栈内存 Stack)</p></li><li><p>在全局的执行上下文中有一个VO(GLOBAL)全局变量对象，可以把代码中的变量和对应的值存储到这里面</p><h4 id="创建变量的顺序"><a href="#创建变量的顺序" class="headerlink" title="创建变量的顺序"></a>创建变量的顺序</h4><ul><li><p>先将值存到真内存中（值是基本类型的值）</p></li><li><p>创建一个变量 ,把变量存到VO(GLOBAL)中</p></li><li><p>让创建的变量和值进行关联在一起</p><p><img src="https://s1.ax1x.com/2020/09/05/wE9LDS.md.png" alt="创建一个变量过程图"></p></li></ul></li></ul><pre><code>    //练习    let a=12;    let b=a;        b=13;    console.log(a)</code></pre><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ul><li><p>首先浏览器创建一个会提供一个代码运行环境栈内存</p></li><li><p>在栈内存中有一个VO全局变量，来储存变量和基本数据类型的值</p></li><li><p>开始运运行代码，let a=12</p><ol><li>现在VO中创建值12</li><li>然后在创建一个变量a</li><li>最后将a和12关联在一起</li></ol></li><li><p>继续执行代码，let b=a;</p><ol><li>首先创建值a（a是一个变量，已经创建过了所以直接跳过）</li><li>创建变量b</li><li>最后将b和a关联在一起，（现在a的值是12，所以b的值也是12）</li></ol></li><li><p>继续执行代码,  b=13;</p><ol><li>将b的值重新赋值为13</li><li>因一个变量只能指向同一个变量所以切断了和a的关联（也就是12）</li></ol></li><li><p>最后代码输出 ， console.log(a)</p><ul><li>此时可以得出a还是那个值12，而b的值已经变为了13</li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/09/05/wAXiRS.md.png" alt="代码执行过程图"></p><pre><code>//练习let n=&#123;    name:&#39;teal&#39;&#125;;let m=n;m.name=&#39;red&#39;;console.log(a.name);</code></pre><h4 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h4><ul><li><p>首先浏览器提供一个代码执行环境栈内存</p></li><li><p>在栈内存中有一个VO全局变量存储</p></li><li><p>代码执行 ，let n={name:’teal’}</p><ol><li>首先创建值，因创建的值不是基本数据类型，所以在内存中开辟一个堆内存，堆内存的地址为AAAFFF111</li><li>在VO中存储堆内存的地址</li><li>创建一个变量n</li><li>让变量n指向这个堆内存的地址</li></ol></li><li><p>代码继续执行，let m=n;</p><ol><li>创建值n,因n是一个变量已经被创建，所以跳过</li><li>创建变量b</li><li>让变量b和变量a关联(也是执行堆内存的地址)</li></ol></li><li><p>代码继续执行， m.name=’red’</p><ol><li>让变量m中的name属性重新赋值为:‘red’</li><li>此时m和n是执行的是同一个堆内存地址，所以堆内存中的nama属性值变为了：’red’</li></ol></li><li><p>最后输出代码值，console.log(n,name);</p><ol><li>此时n.name的值不再是 ‘teal’,而是新值 ’red‘</li></ol></li></ul><p><img src="https://s1.ax1x.com/2020/09/05/wAXPG8.md.png" alt="代码执行过程图"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面试题一</title>
      <link href="/posts/jswor/"/>
      <url>/posts/jswor/</url>
      
        <content type="html"><![CDATA[<h1 id="栈内存与堆内存"><a href="#栈内存与堆内存" class="headerlink" title="栈内存与堆内存"></a>栈内存与堆内存</h1><h1 id="js练习面试题一"><a href="#js练习面试题一" class="headerlink" title="js练习面试题一"></a>js练习面试题一</h1><h2 id="一、问答题"><a href="#一、问答题" class="headerlink" title="一、问答题"></a>一、问答题</h2><ol><li><h3 id="js中常用的数据类型都有哪些？"><a href="#js中常用的数据类型都有哪些？" class="headerlink" title="js中常用的数据类型都有哪些？"></a>js中常用的数据类型都有哪些？</h3><blockquote><h4 id="基本数据类型：string-number-boolean-null-undefined-symbol-bigint"><a href="#基本数据类型：string-number-boolean-null-undefined-symbol-bigint" class="headerlink" title="基本数据类型：string number boolean null undefined symbol bigint"></a>基本数据类型：string number boolean null undefined symbol bigint</h4><h4 id="引用数据类型："><a href="#引用数据类型：" class="headerlink" title="引用数据类型："></a>引用数据类型：</h4><h5 id="object-普通对象-数组对象-正则对象"><a href="#object-普通对象-数组对象-正则对象" class="headerlink" title="object: 普通对象  数组对象  正则对象"></a>object: 普通对象  数组对象  正则对象</h5><h5 id="function"><a href="#function" class="headerlink" title="function"></a>function</h5></blockquote></li><li><h3 id="浏览器中常用的内核有哪些？"><a href="#浏览器中常用的内核有哪些？" class="headerlink" title="浏览器中常用的内核有哪些？"></a>浏览器中常用的内核有哪些？</h3><blockquote><h4 id="Webkit内核、Gecko内核、Trident内核、Blink内核"><a href="#Webkit内核、Gecko内核、Trident内核、Blink内核" class="headerlink" title="Webkit内核、Gecko内核、Trident内核、Blink内核"></a>Webkit内核、Gecko内核、Trident内核、Blink内核</h4></blockquote></li><li><h3 id="数据类型直接的区别？"><a href="#数据类型直接的区别？" class="headerlink" title="数据类型直接的区别？"></a>数据类型直接的区别？</h3><blockquote><h4 id="基本数据类型存储在栈内存中，而引用数据类型存储在堆内存中"><a href="#基本数据类型存储在栈内存中，而引用数据类型存储在堆内存中" class="headerlink" title="基本数据类型存储在栈内存中，而引用数据类型存储在堆内存中"></a>基本数据类型存储在栈内存中，而引用数据类型存储在堆内存中</h4></blockquote></li><li><h3 id="列举常用的关键字和保留字"><a href="#列举常用的关键字和保留字" class="headerlink" title="列举常用的关键字和保留字"></a>列举常用的关键字和保留字</h3><blockquote><p><strong>关键字</strong>：break、else、new、var、case、finally，return，void、catch、for、switch、while、continue、function、this、with、default、if、throw、delete、in、try、do、instanceof、typeof</p><p><strong>保留字</strong>：abstract、enum、int 、short、boolean、export、interface、static、byte、extends、long、super、char、final、native、synchronized、class、float、package、throws、const、goto、private、transient、debugger、implements、protected、volatile、double、import、public</p></blockquote></li><li><h3 id="js中创建变量的几种常用方式？"><a href="#js中创建变量的几种常用方式？" class="headerlink" title="js中创建变量的几种常用方式？"></a>js中创建变量的几种常用方式？</h3><blockquote><p>var   </p><p>let</p><p>const </p><p>class</p><p>function</p><p>import</p></blockquote></li></ol><h2 id="二、练习题"><a href="#二、练习题" class="headerlink" title="二、练习题"></a>二、练习题</h2><ol><li><h3 id="写出下面结果输出答案（阿里面试题）"><a href="#写出下面结果输出答案（阿里面试题）" class="headerlink" title="写出下面结果输出答案（阿里面试题）"></a>写出下面结果输出答案（阿里面试题）</h3><pre><code>let a=&#123;    n:1&#125;;let b=a;a.x=a=&#123;    n:2&#125;;console.log(a.x);// undefinedconsole.log(b); // &#123;n:1,x:&#123;n:2&#125;&#125;</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p><strong>考试点：连等号的运用</strong></p><p><strong>分析图</strong></p><p><img src="https://s1.ax1x.com/2020/09/05/wVC3Tg.md.png" alt="解题过程图"></p></li><li><h3 id="分别写出下列表式输出的结果（腾讯面试题）"><a href="#分别写出下列表式输出的结果（腾讯面试题）" class="headerlink" title="分别写出下列表式输出的结果（腾讯面试题）"></a>分别写出下列表式输出的结果（腾讯面试题）</h3><pre><code>var a=&#39;abc&#39;+123+456; // =&gt;加号不经有数学运算还有字符串的拼接,只要字符串中有非法数字，就直接进行字符串拼接var b=&#39;456&#39;-&#39;123&#39;; // =&gt;将字符串中内容转换为数字类型( 456-123 )，在进行数学运算var c=100+true+21.2+null+undefined+&#39;Tencent&#39;+[]+null+9+false; // =&gt;看到加号先将字符串转换为数字(100+1+21.2+null+NaN+&#39;Tencent&#39;+&#39;&#39;+&#39;null&#39;+&#39;9&#39;+&#39;false&#39;),看到转换后为NaN的后面的不会再转数字类型，而是转字符串，然后在进行字符串拼接console.log(a);//&quot;abc123456&quot;console.log(b);//333console.log(c);//&quot;NaNTencentnull9false&quot;</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p><strong>考点：</strong>字符串的拼接及类型间的转换</p></li></ol><ol start="2"><li><h3 id="写出下列代码的输出结果（腾讯面试题）"><a href="#写出下列代码的输出结果（腾讯面试题）" class="headerlink" title="写出下列代码的输出结果（腾讯面试题）"></a>写出下列代码的输出结果（腾讯面试题）</h3><pre><code>var str=&#39;abc123&#39;;var num=parseInt(str); // =&gt;parseInt()转换规则和Number()不一样,他是先将内容(非数字内容)转换为字符串，从字符串左边开始查找，把找到的有效数字转换为数字，一直到非有效数字字符为止，则结束查找。如开始就是非有效数字直接转换为数字NaNif(num==NaN)&#123; // =&gt;NaN和任何数都不想等    alert(NaN);&#125;else if(num==123)&#123;    alert(123);&#125;else if(typeof num==&#39;number&#39;)&#123;   // =&gt;typeof 输出的值都会被转换为字符串    alert(&#39;number&#39;); //正确的输出结果&#125;else&#123;    alert(&#39;str&#39;);&#125;;</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p><strong>考点：</strong>parseInt()转换规则  </p></li></ol><ol start="3"><li><h3 id="写出下列代码的输出结果（腾讯面试题）-1"><a href="#写出下列代码的输出结果（腾讯面试题）-1" class="headerlink" title="写出下列代码的输出结果（腾讯面试题）"></a>写出下列代码的输出结果（腾讯面试题）</h3><pre><code>var a=0;var b=a;b++;alert(a);var o=&#123;&#125;;o.a=0;var c=o;c.a=10;alert(o.a);</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p><strong>考点：</strong> 基本数据类型和引用数据类型的区别</p><p><strong>分析图</strong></p><p><img src="https://s1.ax1x.com/2020/09/05/wVelnA.md.png" alt="分析过程图"></p></li></ol><ol start="4"><li><h3 id="下列输出”1”的有哪些？"><a href="#下列输出”1”的有哪些？" class="headerlink" title="下列输出”1”的有哪些？"></a>下列输出”1”的有哪些？</h3><pre><code>A:alert(1) // &quot;1&quot; =&gt;alert输出的内容都会被转换为字符串B:console.log(parseInt(1.3)); // 1  =&gt;parseInt会将非数字转换为字符串，然后将有自左向右按个查找有效数字，一直遇到非有效数字停止检查，然后将有效数字转换为数字类型C:console.log(1);//1 =&gt;consoel.log输出的是值原本的类型不会被转换D:console.log(isNaN(1));// false =&gt;isNaN检测内容是否为NaN,它会将非数字类型，通过Number转换为数字类型，是NaN输出true,不是NaN输出falseE:console.log(parseInt(&quot;1&quot;)); // 1答案：A</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：parsrInt()转换  isNaN()判断</p></li></ol><ol start="5"><li><h3 id="下面结果是”undefined”的是"><a href="#下面结果是”undefined”的是" class="headerlink" title="下面结果是”undefined”的是"></a>下面结果是”undefined”的是</h3><pre><code>A:console.log(alert(1));// undefined =&gt;先输出alert的值(&quot;1&quot;),然后将alert执行后的返回值在控制台输出，而alert没有返回值B:typeof undefined // &quot;undefined&quot; =&gt;typeof输出的值类型都会被转换为字符串C:console.log(parseInt(undefined));// NaN =&gt;先将undefined转换为数字类型(NaN)，然后在进行输出D:isNaN(undefined);// true  =&gt;先将undefined通过Number转换为最后NaN,最后判断是否为NaN答案：B</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：typeof 输出结果类型  嵌套输出结果</p></li></ol><ol start="6"><li><h3 id="下面结果能得到true的是"><a href="#下面结果能得到true的是" class="headerlink" title="下面结果能得到true的是"></a>下面结果能得到true的是</h3><pre><code>A:isNaN(null); // false =&gt;先将null通过Number转换为数字类型(0),在判断是否为NaNB:isNaN(parseInt(null));// true =&gt;parseInt先将null转换字符串，然后将有效数字转换为数字类型(NaN),然后判断是否为NaNC:Number(null);// 0 =&gt;直接将内容转换为数字类型(0)D:parseFloat(null);// NaN //将内容转换为字符串然后将有效字符转换为数字类型(NaN)答案:B</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：isNaN判断  parseInt转换  Number转换  parseFloat转换</p></li></ol><ol start="7"><li><h3 id="输出下面程序的结果"><a href="#输出下面程序的结果" class="headerlink" title="输出下面程序的结果"></a>输出下面程序的结果</h3><pre><code>parseInt(&quot;&quot;);// NaN =&gt;将内容转换为字符串，然后将有效字符转换为数字类型(NaN)Number(&quot;&quot;);// 0 =&gt;将内容直接转换为数字类型(0)isNaN(&quot;&quot;);// false =&gt;先将内容转换数字类型(0),然后在判断是否为NaNparseInt(null);// NaN =&gt;将内容转换为字符串，然后自左往右查询有效数字，一直遇到非有效数字为止，结束查询，将有效数字转换为数字类型(NaN)Number(null);// 0 =&gt; 直接将转换为数字类型(0)isNaN(null);// false =&gt;直接转换为数字内容(0),然后判断是否为NaNuparseInt(&quot;12px&quot;);// 12 =&gt;先将内容转化为字符串然后自左往右查询，一直查询到非有效数字为止，结束查询。将有效数字转换为数字类型(12)Number(&#39;12px&#39;);// NaN =&gt;直接内容转换为数字类型(NaN)isNaN(&quot;12px&quot;);//true =&gt;直接将内容转换为数字类型(NaN),然后判断是否为NaN</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：各数据类型间的数据转换</p></li></ol><ol start="8"><li><h3 id="下面程序数据的结果"><a href="#下面程序数据的结果" class="headerlink" title="下面程序数据的结果"></a>下面程序数据的结果</h3><pre><code>if(isNaN(NaN)==&quot;&quot;)&#123;     // =&gt;先判断是否为NaN(true),=&gt; true==&quot;&quot; ,然后将true转化为字符串,在进行比对    console.log(&#39;teal&#39;);&#125;else&#123;    console.log(&#39;red&#39;); // &quot;red&quot;&#125;;</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：相等和全等</p></li></ol><ol start="9"><li><h3 id="下面程序的输出的结果"><a href="#下面程序的输出的结果" class="headerlink" title="下面程序的输出的结果"></a>下面程序的输出的结果</h3><pre><code>let x=[1,2,3];let y=x;let z=[4,5,6];y[0]=10;y=z;z[1]=20;x[2]=z=30;console.log(x,y,z)</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点： 栈与堆内存</p><p>分析图</p><p><img src="https://s1.ax1x.com/2020/09/05/wVYgdU.md.png" alt="分析过程图"></p></li></ol><ol start="10"><li><h2 id="下面程序的输出结果（阿里面试题）"><a href="#下面程序的输出结果（阿里面试题）" class="headerlink" title="下面程序的输出结果（阿里面试题）"></a>下面程序的输出结果（阿里面试题）</h2><pre><code>let a=&#123;    n:1&#125;;let b=a;a.x=a=&#123;    n:2&#125;;conosle.log(a.x);console.log(b)</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>分析图</p><p><img src="https://s1.ax1x.com/2020/09/05/wVtbXq.md.png" alt="分析过程图"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试练习二</title>
      <link href="/posts/jswor2/"/>
      <url>/posts/jswor2/</url>
      
        <content type="html"><![CDATA[<h1 id="试题二"><a href="#试题二" class="headerlink" title="试题二"></a>试题二</h1><h2 id="数据类型基础知识"><a href="#数据类型基础知识" class="headerlink" title="数据类型基础知识"></a>数据类型基础知识</h2><pre><code>!(!&quot;Number(undefined)&quot;);//true》过程: !(false)=&gt;true》解析: 先将字符串进行取反为false,然后在取反true</code></pre><pre><code>isNaN(parseInt(new Date()))+Number([1])+typeof undefined;//&quot;2undefined&quot;》过程: isNaN(NaN)+1+&quot;undefined&quot; =&gt; true+1+&quot;undefined&quot; =&gt; 1+1+“undefined&quot; =&gt; &quot;2undefined&quot;》解析: 先计算括号内的parseInt(new Date()),结果为NaN,然后在计算外面在判断NaN是否为NaN结果为true。在计算Number([1])里的值，结果为1。在判断undefined为undefined类型，最后将所有值运算&quot;2undefined&quot;</code></pre><pre><code>Boolean(Number(&quot;&quot;))+!isNaN(Number(null))+Boolean(&quot;parseInt([])&quot;)+typeof !(null);//&quot;2boolean&quot;》过程：Boolean(0)+!isNaN(0)+true+typeof true =&gt;false+true+true+&quot;boolean&quot;&gt;&quot;2boolean&quot;》解析：先计算括号里的Number(&quot;&quot;)的值为0，然后在转换为布尔类型false。在计算Number(null)的结果为0，然后在判断是否为NaN结果为false,然后再取反为true。将boolean括号里的内容转换为布尔类型true.判断!null为什么类型结果为boolean,最后计算结果为&quot;2boolean&quot;</code></pre><pre><code>parseFloat(&#39;1.6px&#39;)+parseInt(&#39;1.2px&#39;)+typeof parseInt(null);//&quot;2.6number&quot;》过程：1.6+1+”number&quot;=&gt;&quot;2.6number&quot;》解析：先将parseFloat里的内容转换为浮点数1。然后再将parseInt里的字符串转换为数字类型1。在判断parseInt(null)的类型为number,最后将结果进行运算的&quot;2.number&quot;</code></pre><pre><code>isNaN(Number(!!Number(parseInt(&quot;0.8&quot;))));//false》过程：isNaN(Number(!!Number(0))) =&gt;isNaN(Number(false)) =&gt;isNaN(0)=&gt;false》解析：先计算parserInt(&quot;0.8&quot;),结果为0，然后在将0通过Number转换为数字类型，取反再取反为false,然后将false通过Number转换为数字类型0，最后判断0是否是NaN,结果为false</code></pre><pre><code>console.log(1+&#39;2&#39;+&#39;2&#39;);//&quot;122&quot;》过程：&quot;122&quot;》解析：直接将内容进行拼接结果运算为&quot;122&quot;</code></pre><pre><code>!typeof parseFloat(&quot;0&quot;);//false》过程：!typeof 0 =&gt;!number =&gt;false》解析：先计算psrseFloat里的浮点数为0，在判断0是number类型，最后将number类型转换为布尔类型false</code></pre><pre><code>Number(&quot;&quot;);//0》过程：&quot;0&quot;》解析：直接将结果运算&quot;0&quot;</code></pre><pre><code>typeof &quot;parseInt(null)&quot; +12+!!Number(NaN);//&quot;string12false&quot;》过程：&quot;string12&quot;+false =&gt;&quot;stringfalse&quot;》解析：先判断是否为类型为&quot;string&quot;类型，然后将&quot;string&quot;和12进行拼接，最后判断number(NaN)，转换为数字为NaN,取反在取反，得到布尔类型false,最后将拼接字符串”string12false“</code></pre><pre><code>!typeof (isNaN(&quot;&quot;))+parseInt(NaN);//NaN》过程：!typeof (false)+NaN =&gt;!boolean+NaN =&gt;false+NaN =&gt;NaN》解析：先判断isNaN(&quot;&quot;)是否为NaN,结果为false,然后在判断false的类型为&quot;boolean&quot;,然后转换为布尔类型false，在判断parseInt(Nan)的结果为NaN,最后再将结果进行运算为NaN</code></pre><pre><code>typeof !parseInt(null)+!isNaN(null);//&quot;booleabtrue&quot;》过程：typeof !NaN+!false =&gt;typeof true+true =&gt;&quot;boolean&quot;+true =&gt;&quot;booleantrue&quot;》解析：先将psrseInt(null)转换为数字类型NaN,在取反的true,在判断true的类型为&quot;boolean&quot;,判断isNaN(null)的结果为false,然后取反结果为true,最后将字符串进行拼接的&quot;booleantrue&quot;</code></pre><h2 id="栈与堆内存"><a href="#栈与堆内存" class="headerlink" title="栈与堆内存"></a>栈与堆内存</h2><blockquote><p>修改盒子中文字颜色样式的三种写法，哪一种可以？</p></blockquote><pre><code>// 1let box=document.getElementById(&#39;box&#39;);box.style.color=&#39;red&#39;;// 可以// 2let boxSty=box.style;boxSty.coloe=&#39;green&#39;; // 可以// 3let text=box.style.color;text=&#39;blue&#39;; // 不可以</code></pre><p>详细过程图</p><p><img src="https://s1.ax1x.com/2020/09/07/wuFXoq.md.png" alt="过程图"></p>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中boolean数据类型</title>
      <link href="/posts/jsboolean/"/>
      <url>/posts/jsboolean/</url>
      
        <content type="html"><![CDATA[<h1 id="js中boolean数据类型"><a href="#js中boolean数据类型" class="headerlink" title="js中boolean数据类型"></a>js中boolean数据类型</h1><h2 id="将其他数据类型转换为布尔类型"><a href="#将其他数据类型转换为布尔类型" class="headerlink" title="将其他数据类型转换为布尔类型"></a>将其他数据类型转换为布尔类型</h2><ul><li>Boolean([value])</li><li>![value]; 把指定的值转换为布尔类型，在取反</li><li>!![value]; 把指定的值转换为布尔类型然后取反在取反（相当于将指定的值转换为布尔类型而已）</li></ul><blockquote><p>规则：只有 “ 0  NaN  null undefined  空字符串 “最后会转换为false ,其余都为true</p></blockquote><pre><code>conosle.log(!!-1); // =&gt;trueconsole.log(!!0); // =&gt;falseconsole.log(!!undefined); // =&gt;falseconsole.log(!!Number(&#39;12px&#39;)); // =&gt;falseconsole.log(!![]); // =&gt;trueconsole.log(!! &#39;&#39;); // =&gt;falseconsole.log(!!&#123;&#125;); // =&gt;true</code></pre><blockquote><p>条件判断中，每一个条件最后都会被转换为 true || false</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> boolean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中Object数据类型</title>
      <link href="/posts/jsobject/"/>
      <url>/posts/jsobject/</url>
      
        <content type="html"><![CDATA[<h1 id="js中object数据类型"><a href="#js中object数据类型" class="headerlink" title="js中object数据类型"></a>js中object数据类型</h1><h2 id="所有的对象都具备的特点"><a href="#所有的对象都具备的特点" class="headerlink" title="所有的对象都具备的特点"></a>所有的对象都具备的特点</h2><ol><li><p>用键值对（key:value俗称属性和属性值）来描述一个对象的特征（每一个对象都会综合体,存在零到多个键值对）</p></li><li><p>{[key:value,…]}每一组键值对是key:value的格式，多组键值对用逗号分隔</p></li><li><p>key不能是引用数据类型，value可以是任意数据类型</p><pre><code>let obj=&#123;    name:&#39;teal&#39;,    age:20,    hobby:[&#39;吃饭&#39;,&#39;睡觉&#39;],    skill:function()&#123;&#125;&#125;console.log(obj);&gt;&#123;name: &quot;teal&quot;, age: 20, hobby: Array(2), skill: ƒ&#125;</code></pre></li></ol><h2 id="关于对象中的键值对的增删改查"><a href="#关于对象中的键值对的增删改查" class="headerlink" title="关于对象中的键值对的增删改查"></a>关于对象中的键值对的增删改查</h2><ul><li><p>新增或修改属性和属性值</p><p>操作属性的两种方式</p><ol><li><p>对象.属性名=属性值</p></li><li><p>对象[属性名]=属性值</p><pre><code>let obj=&#123;&#125;;//新增属性console.log(obj.name=&#39;teal&#39;); // =&gt;&#39;teal&#39;console.log(obj[&#39;age&#39;]=20); // =&gt;20//修改属性值console.log(obj.age=30); // =&gt;30console.log(obj[&#39;name&#39;]=&#39;red&#39;); // =&gt;&#39;red&#39;</code></pre></li></ol></li><li><p>获取对象中的属性和属性值</p><ol><li><p>​    获取指定属性名的属性值</p><pre><code>let obj=&#123;    name:&#39;teal&#39;,    age:20&#125;console.log(obj.name); // =&gt;&quot;teal&quot;console.log(obj[&#39;age&#39;]); // =&gt;20</code></pre></li><li><p>如果指定的属性不存在，获取到的值为undefined(不会报错)</p><pre><code>let obj=&#123;&#125;;console.log(obj.name); // =&gt;undefinedconsole.log(obj[&#39;age&#39;]); // =&gt;undefined</code></pre></li><li><p>获取当前对象中所有的属性名=&gt;返回的结果包含所有属性名的数组</p><pre><code>let obj=&#123;    name:&#39;teal&#39;,    age:20,    hobby:[&#39;吃饭&#39;,&#39;睡觉&#39;]    &#125;console.log(obj); // =&gt;&#123;name: &quot;teal&quot;, age: 20, hobby: Array(2)&#125;</code></pre></li></ol></li><li><p>删除对象中指定的属性</p><ol><li><p>假删除：当前属性还存在，只不过属性值为空</p><pre><code>let obj=&#123;    name:&#39;teal&#39;&#125;obj.name=nullconsole.log(obj.name); // =&gt;null </code></pre></li><li><p>真删除：彻底将对象中的属性删除</p><pre><code>let obj=&#123;    name:&#39;teal&#39;&#125;;delete obj.nameconsole.log(obj[&#39;name&#39;]); // =&gt;undefined</code></pre></li></ol></li></ul><h2 id="对象中的属性名不能是引用数据类型"><a href="#对象中的属性名不能是引用数据类型" class="headerlink" title="对象中的属性名不能是引用数据类型"></a>对象中的属性名不能是引用数据类型</h2><pre><code>let n=10;let obj=&#123;&#125;;obj.n=200;// =&gt;相当于在obj中添加一个名为n的值为200的属性console.log(obj[&#39;n&#39;]); // =&gt;200obj[&#39;n&#39;]=300;// =&gt;相当于将刚创建名为n的属性值改为了300console.log(obj.n); // =&gt;300obj[n]=400;// =&gt;将创建的变量的值当作了属性名console.log(obj); // =&gt;&#123;10: 400, n: 300&#125;</code></pre><blockquote><p>n本身是一个变量（n和”n”的区别：前者是一个变量，后者是一个字符串的值），他代表的是所存储的值为100(是一个数字格式)</p></blockquote><ul><li><p>基于对象[属性名]的方式操作，需要保证属性名是一个变量（字符串  数字  布尔等都可以），如果不是值而是一个变量，他会把变量存储的值作为对象的属性名进行操作</p></li><li><p>基于对象.属性名的方式操作，属性名就是点后面的</p><pre><code>let obj=&#123;    1:100&#125;;console.log(obj[&#39;1&#39;]); // =&gt;100console.log(obj.1);//=&gt;Uncaught SyntaxError: missing ) after argument list</code></pre><blockquote><p>基于点的方式操作自己的有局限性，属性名不能是数字。此时只能用对象[属性名]的方式获取</p></blockquote></li><li><p>对象作为属性名操作的后果</p><pre><code>let n=&#123;a:20&#125;;let m=[100,200];let obj=&#123;&#125;;obj[n]=&#39;teal&#39;;// =&gt;obj[&#123;n:100&#125;]但是对象不能最为属性名，所以需要把其转换为字符串console.log(obj); // =&gt;&#123;[object Object]: &quot;teal&quot;&#125;obj[m]=100;console.log(obj); // =&gt;&#123;[object Object]: &quot;teal&quot;, 100,200: 100&#125;</code></pre></li></ul><h2 id="数组是特殊的对象"><a href="#数组是特殊的对象" class="headerlink" title="数组是特殊的对象"></a>数组是特殊的对象</h2><ol><li><p>他的属性名是数字，数字从零开始，逐级递增，每一个数字都代表当前的位置(我们将这种数字属性名称为”索引”</p></li><li><p>默认有一个length属性存储数组的长度</p><pre><code>let arr=[10,20,30];console.log(arr[0],arr[1],arr[2]);// =&gt;10,20,30console.log(arr.length); //=&gt; 3</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中关于String数据类型</title>
      <link href="/posts/jsstring/"/>
      <url>/posts/jsstring/</url>
      
        <content type="html"><![CDATA[<h1 id="js中关于String数据类型"><a href="#js中关于String数据类型" class="headerlink" title="js中关于String数据类型"></a>js中关于String数据类型</h1><blockquote><p>在js中用 ：单引号 双引号  反引号 包起来的都是字符串</p></blockquote><h2 id="把其他类型的值转换为字符串类型"><a href="#把其他类型的值转换为字符串类型" class="headerlink" title="把其他类型的值转换为字符串类型"></a>把其他类型的值转换为字符串类型</h2><ul><li>String([value])</li><li>[value].toString()</li></ul><blockquote><p>普通对象转换为字符串都是 ：”[object object]”</p><p>数组对象转换为字符串是 ：”第一项，第二项，…” ; // =&gt;(以逗号分隔数组中的每一项)</p></blockquote><h2 id="在js中常用的数学运算"><a href="#在js中常用的数学运算" class="headerlink" title="在js中常用的数学运算"></a>在js中常用的数学运算</h2><ul><li><p>数学运算：+  -  *  /     //=&gt;加减乘除</p></li><li><p>％(膜) 取余数</p><pre><code>console.log(4 / 2); // =&gt;2console.log(7 / 3); // =&gt;2.3333333333333335console.log(7 % 3); // =&gt;1</code></pre></li><li><p>除了加法以外，其余的情况都是数学运算（如果遇到非数字类型，需要将其利用Number方式转换为数字类型，然后在运算）</p></li><li><p>加号在Js中既有数学运算也有字符串拼接的意思（只要加号两边的任意一边出现字符串，则变为字符串拼接）</p><pre><code>console.log(3-&#39;3px&#39;); // =&gt;NaNconsole.log(3+&#39;3px&#39;); // =&gt;&quot;33px&quot;console.log(1+&#39;1&#39;); // =&gt;&quot;11&quot;console.log(1+&#123;&#125;); // =&gt;&quot;1[object object]&quot;console.log(1+[]); // =&gt;&#39;1&#39;console.log([10]+true); // =&gt;&quot;10true&quot;  在转换为[10]到数字的过程中，先将其转换为字符串&quot;10&quot;，此后在进行字符串拼接(和数学运算没关系了)console.log(true+[10]); // =&gt;&quot;true10&quot;console.log(1+true); // =&gt;2console.log(100+true+21.2+null+undefined+&quot;tencent&quot;+[]+null+9+false); // =&gt;&quot;NaNtencentnull9falset&quot;</code></pre></li></ul><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><h3 id="传统字符串拼接"><a href="#传统字符串拼接" class="headerlink" title="传统字符串拼接"></a>传统字符串拼接</h3><pre><code>// 将下列变量拼接成 2020-09-04 12:00:00这种格式输出let year=&quot;2020&quot;;let month=&quot;09&quot;;let day=&quot;04&quot;;let hours=&quot;12&quot;;let minute=&quot;00&quot;;let second=&quot;00&quot;;let result=year+&#39;-&#39;+month+&#39;-&#39;+day+&#39; &#39;+hours+&quot;:&quot;+minute+&quot;:&quot;+second;console.log(result); // =&gt;2020-09-04 12:00:00</code></pre><h3 id="ES6模板字符串拼接"><a href="#ES6模板字符串拼接" class="headerlink" title="ES6模板字符串拼接"></a>ES6模板字符串拼接</h3><blockquote><p>es6中的模板字符串就是解决了传统字符串拼接的问题（反引号 Tab键上面的~）</p><p>${}中存方变量或其他js表达式即可，不用考虑单引号和双引号问题</p></blockquote><pre><code>// 将下列变量拼接成 2020-09-04 12:00:00这种格式输出let year=&quot;2020&quot;;let month=&quot;09&quot;;let day=&quot;04&quot;;let hours=&quot;12&quot;;let minute=&quot;00&quot;;let second=&quot;00&quot;;let result =`$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hours&#125;:$&#123;minute&#125;:$&#123;second&#125;`;console.log(result); // =&gt;2020-09-04 12:00:00</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中typeof数据检测</title>
      <link href="/posts/jstypeof/"/>
      <url>/posts/jstypeof/</url>
      
        <content type="html"><![CDATA[<h1 id="js中typeof数据检测"><a href="#js中typeof数据检测" class="headerlink" title="js中typeof数据检测"></a>js中typeof数据检测</h1><h2 id="js中的数据检测"><a href="#js中的数据检测" class="headerlink" title="js中的数据检测"></a>js中的数据检测</h2><ul><li>typeof [value]; 检测数据的类型</li><li>[example] instanceof [class]; 检测数据类型</li><li>[example].constructor===[class];检测实例和类关系的，从而检测数据类型</li><li>Object.prototype.toString.call([value]);检测数据类型</li></ul><h2 id="typeof的细节点："><a href="#typeof的细节点：" class="headerlink" title="typeof的细节点："></a>typeof的细节点：</h2><ol><li><p>typeof检测的结果首先是一个字符串，字符串中包含了对应的数据类型（如：’number’、‘string’、’boolean’、’undefined’、’object’、’function’、‘symbol’、’bigint’)</p></li><li><p>特殊的检测结果；</p><ul><li><p>NaN/Infinity都是数字类型的，检测结果都为：”number”</p></li><li><p>null的结果是”object”(这是浏览器的BUG：所有的值在计算中都已二进制存储，浏览器中把前三位000的最为对象，而null的二进制前三位就是000，所以被识别为对象，但事实上他不是对象，他是对象指针，是基本数据类型）</p></li><li><p>普通对象/数组对象/正则对象都是”object”类型，这样就无法基于typeof区分普通对象还是数组对象了</p></li><li><p>检测小技巧</p><pre><code>console.log(typeof []); // =&gt;&quot;object&quot;console.log(typeof typeof typeof []); //=&gt;&quot;string&quot;</code></pre><blockquote><p>由于typeof返回的结果是一个字符串（字符串中包含了对应的类型），所以连续出现两次及两次以上的typeof检测的结果都是“string”</p></blockquote></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> typeof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用浏览器内核</title>
      <link href="/posts/brower/"/>
      <url>/posts/brower/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1、以谷歌浏览器Webkit内核为主（v8引擎）</p></blockquote><blockquote><p>2、火狐的 Gecko内核</p></blockquote><blockquote><p>3、IE浏览器的Trident内核</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的数据类型</title>
      <link href="/posts/jsdataclass/"/>
      <url>/posts/jsdataclass/</url>
      
        <content type="html"><![CDATA[<h1 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h1><h2 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h2><ul><li>数值 Number </li><li>字符串 String </li><li>布尔值 Boolean </li><li>空值 Null //undefined</li><li>未定义 Undefined </li><li>ES6新增的唯一的类型 Symbol</li></ul><h2 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h2><ol><li><p>对象数据类型 Object</p><ul><li>普通对象 {}</li><li>数组对象 []</li><li>正则表达式  /^$/</li><li>日期对象 new Date</li><li>数学函数对象 Math</li><li>…</li></ul><p>2、函数数据类型 Function</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中关于number的内容</title>
      <link href="/posts/jsnumber/"/>
      <url>/posts/jsnumber/</url>
      
        <content type="html"><![CDATA[<h1 id="关于javascript中关于number的学习内容"><a href="#关于javascript中关于number的学习内容" class="headerlink" title="关于javascript中关于number的学习内容"></a>关于javascript中关于number的学习内容</h1><h2 id="number数据类型包括那些"><a href="#number数据类型包括那些" class="headerlink" title="number数据类型包括那些"></a>number数据类型包括那些</h2><ul><li>正数、负数、浮点数、零</li><li>NaN  =&gt;NaN表示not a Number不是一个有效数字，但他属于number类型</li><li>Infinity:=&gt;表示无穷大的值 -Infinity=&gt;表示负的无穷的值</li></ul><h2 id="关于NaN"><a href="#关于NaN" class="headerlink" title="关于NaN"></a>关于NaN</h2><blockquote><p>NaN和任何数都不想等，包括他自己</p><pre><code>console.log(NaN=10); // =&gt;falseconsole.log(NaN==NaN); // =&gt;false</code></pre></blockquote><h2 id="强制将其他数据类型转换为数字"><a href="#强制将其他数据类型转换为数字" class="headerlink" title="强制将其他数据类型转换为数字"></a>强制将其他数据类型转换为数字</h2><ul><li><p>字符串：把字符串转换为数字，一旦发现字符串中出现非有效数字的字符，则结果为NaN.只有字符串中都是有效数字才能转换为具体的数字，空字符串换转换为0</p><pre><code>console.log(Number(&#39;10&#39;)); // =&gt;10console.log(Number(&#39;10px&#39;)); // =&gt;NuNconsole.log(Number()); // =&gt;0</code></pre></li><li><p>布尔值：把布尔值转换为数字=&gt; true转换为1 ，false转换为0</p><pre><code>console.log(Number(true)); // =&gt;1console.log(Number(false)); // =&gt;0</code></pre></li><li><p>空值： 把空值转换为数字=&gt; null转换为0    undefined转换为NaN</p><pre><code>console.log(Number(null)); // =&gt;0console.log(Number(undefined)); // =&gt;NaN</code></pre></li><li><p>symbol: 不能将symbol类型转换为数字，否则会报错</p><pre><code>console.log(Number(symbol)); // =&gt;Uncaught ReferenceError: symbol is not defined</code></pre></li><li><p>对象：=&gt;对象转换为数字=&gt;先把对象转换为字符串，再把字符串转换为数字</p><ol><li><p>普通对象转换为数字都为NaN</p></li><li><p>数组转换为数字，只有当数组长度为1，并且数组内的值为有效数字才能转换为对应的数字，或数组为空也可以转换为数字0，其余都转换为NaN</p><pre><code>console.log(Number([])); // =&gt;0console.log(Number([&#39;10&#39;])); // =&gt;10console.log(Number([&#39;aa&#39;])); // =&gt;NaNconsole.log(Number([10,12])); //=&gt;NaN</code></pre></li></ol></li><li><p>函数：函数转换为数字都为NaN</p><pre><code>console.log(Number(function fun()&#123;&#125;)); // =&gt;NaN</code></pre></li></ul><h2 id="Number将其他类型转换为数字的方法"><a href="#Number将其他类型转换为数字的方法" class="headerlink" title="Number将其他类型转换为数字的方法"></a>Number将其他类型转换为数字的方法</h2><ol><li>Number([value]); =&gt;而isNaN在检测是否为有效数字是就是使用的这种方法</li><li>parseInt([value]); </li><li>parsrFloat([value]);</li></ol><h2 id="检测一个数是否为NaN"><a href="#检测一个数是否为NaN" class="headerlink" title="检测一个数是否为NaN"></a>检测一个数是否为NaN</h2><blockquote><p>isNaN()=&gt;想要验证一个数是否是有效数字可以通过使用isNaN()这个方法，是有效数字返回false,不是有效数字返回true</p></blockquote><pre><code>console.log(isNaN(&#39;AA&#39;)); // =&gt; trueconsole.log(isNaN(&#39;12.5’)); // =&gt; falseconsole.log(isNaN(&#39;12.5PX&#39;)); // =&gt; trueconsole.log(isNaN([])); // =&gt; falseconsole.log(isNaN([10])); // =&gt; falseconsole.log(isNaN([10,20])); // =&gt; trueconsole.log(isNaN(&#123;&#125;)); // =&gt; trueconsole.log(isNaN(null)); // =&gt; falseconsole.log(isNaN(undefined)); // =&gt; trueconsole.log(isNaN(symbol)); // =&gt; 报错</code></pre><h2 id="parseInt-parseFloat将其他类型转换为数字"><a href="#parseInt-parseFloat将其他类型转换为数字" class="headerlink" title="parseInt/parseFloat将其他类型转换为数字"></a>parseInt/parseFloat将其他类型转换为数字</h2><ul><li>转换原理和Number转换不一样，他是把字符串转换为数字类型(如果处理的值不是字符串，需要先转换为字符串，然后再去转化为Number类型)</li><li>转换原理：从字符串左边开始查找，把找到得 有效数字转换为数字字符串转换为数字，一直遇到一个非有效数字字符为止，则结束查找</li><li>null/undefined类型都是NaN(先将null转换为普通字符串“null”在转换为数字，结果为NaN,=&gt;所有的字符都一样)</li><li>parseFloat比parseInt只是多识别一个小数点</li></ul><pre><code>console.log(parseInt(&#39;10&#39;));  // =&gt;10console.log(parseInt(&#39;10px&#39;)); // =&gt;10console.log(parseInt(&#39;wdith:20px&#39;)); // =&gt; NaNconsole.log(parseInt(&#39;12.5&#39;)); // =&gt;12console.log(parseFloat(&#39;12.5&#39;)); // =&gt;12.5console.log(parseInt(null)); // =&gt;NaNconsole.log(parseFloat(false)); // =&gt;NaN</code></pre><h2 id="最大安全数："><a href="#最大安全数：" class="headerlink" title="最大安全数："></a>最大安全数：</h2><pre><code>console.log(number_MAX_SAFE_INTEGER); //=&gt;9007199254740991 (Js中最大的安全数=&gt;Js能够识别得最大整数) console.log(9007199254740992==9007199254740993); //=&gt;true(理想结果应该是false,但超过了最大安全数，Js无法精确计算)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中常用的输出方式</title>
      <link href="/posts/jsoutputmode/"/>
      <url>/posts/jsoutputmode/</url>
      
        <content type="html"><![CDATA[<h1 id="js中常用的输出方式"><a href="#js中常用的输出方式" class="headerlink" title="js中常用的输出方式"></a>js中常用的输出方式</h1><h2 id="1、console控制台：在浏览器控制台输出"><a href="#1、console控制台：在浏览器控制台输出" class="headerlink" title="1、console控制台：在浏览器控制台输出"></a>1、console控制台：在浏览器控制台输出</h2><ul><li><p>console.log; =&gt;可以输出任意数据类型，控制台展示的类型也是对应的数据类型</p><pre><code>console.log(&#39;a&#39;,10,&#123;name:&#39;Teal&#39;&#125;,[10,20],false); // =&gt;a 10 &#123;name: &quot;Teal&quot;&#125; (2) [10, 20] false</code></pre></li><li><p>console.dir; =&gt;输出一个对象或一个值得详细信息</p><pre><code>console.dir(&#123;name:&#39;Teal&#39;,age:20&#125;); // =&gt;Object age: 20 name: &quot;Teal&quot; __proto__: Object</code></pre></li><li><p>console.wran; =&gt;输出一个黄色背景的提示信息</p><pre><code>cosnole.wran(&#39;当前操作不符合规范&#39;); // =&gt; 黄色背景：‘当前操作不符合规范’</code></pre></li><li><p>console.table; =&gt;将json数据转化为表格输出</p><pre><code>console.table(&#123;name:&#39;teal&#39;,age:20&#125;)// =&gt;</code></pre><table><thead><tr><th>(index)</th><th>Value</th></tr></thead><tbody><tr><td>name</td><td>“teal”</td></tr><tr><td>age</td><td>20</td></tr></tbody></table></li><li><p>console.time/timeEnd; =&gt;计算中间程序运行的预估时间（预估时间：会受到当前电脑性能的影响）</p><pre><code>console.time(&#39;a&#39;); //a表示当前计算的任务名称for(let i=0;i&lt;99999999;i++)&#123;&#125;console.timeEnd(&#39;a&#39;); // =&gt; a: 51.40185546875 ms</code></pre></li></ul><h2 id="2、window提示框"><a href="#2、window提示框" class="headerlink" title="2、window提示框"></a>2、window提示框</h2><ul><li><p>alert; =&gt;alert是浏览器窗口弹出一个提示框，提示框中输出指定的信息，但输出的是字符串</p><pre><code>alert(20); // =&gt;&quot;20&quot;</code></pre></li><li><p>config;=&gt;相对于alert来说，给用户添加了两个选择按钮，第一个就是确定按钮第二个是取消按钮，我们可以通过用户点击的按钮拿到用户点击了那个按钮</p><pre><code>const bool=confirm(&#39;是否点击&#39;);console.log(bool); // =&gt;点击按钮输出true,点击取消输出false</code></pre></li><li><p>prompt; =&gt;相对于confirm来说在提供按钮的基础上还添加了输入框供用户输入信息，我们可以通过用户点击按钮来拿到用户输入的数据</p><pre><code>const data=prompt(&#39;请输入内容&#39;);cosnole.log(date); // =&gt;如果用户点击了确定按钮就会输出用户输入的值，如果点击了取消就会输出null</code></pre></li></ul><h2 id="3、向页面写入数据"><a href="#3、向页面写入数据" class="headerlink" title="3、向页面写入数据"></a>3、向页面写入数据</h2><ul><li><p>document.write;=&gt;把内容写入到页面中</p><pre><code>document.write(123); // =&gt;&quot;123&quot;</code></pre></li><li><p>innerHTML/innerText；向指定的容器中插入信息，基于这两种方法会把原有的数据给覆盖掉，想要追加内容采用+=方式，innerHTML还可以将语义化标签解析成代码，而innerText会将其当作字符串直接输出</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ZH-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;text&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;box&quot;&gt;123&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    // 读取内容    console.log(document.querySelector(&#39;#box&#39;).innerHTML); // =&gt;&quot;123&quot;    console.log(document.querySelector(&#39;#box&#39;).innerText); //=&gt;&quot;123    //覆盖原有数据    console.log(document.querySelector(&#39;#box&#39;).innerHTML=456) // =&gt;456    console.log(document.querySelector(&#39;#box&#39;).innerText=456) // =&gt;456    //追加内容    console.log(document.querySelector(&#39;#box&#39;).innerHTML+=&#39;aaa&#39;); // =&gt;456aaa    console.log(document.querySelector(&#39;#box&#39;).innerText+=&#39;aaa&#39;); // =&gt;456aaaaaa    //渲染语义化标签    console.log(document.querySelector(&#39;#box&#39;).innerHTML=&#39;&lt;h1&gt;123&lt;/h1&gt;&#39;); // =&gt;一级标题下的123    console.log(document.querySelector(&#39;#box&#39;).innerText=&#39;&lt;h1&gt;123&lt;/h1&gt;&#39;); // =&gt;&quot;&lt;h1&gt;123&lt;/h1&gt;&quot;&lt;/script&gt;</code></pre></li><li><p>value;=&gt;给页面中的input赋值</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ZH-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;text&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   &lt;input type=&quot;text&quot; id=&quot;output&quot;&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    document.querySelector(&#39;#output&#39;).value=&#39;我是输入框中的内容&#39;; // =&gt;在输入框中有“我是输入框中的内容”这几个字&lt;/script&gt;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中定义变量的方法</title>
      <link href="/posts/jsvariable/"/>
      <url>/posts/jsvariable/</url>
      
        <content type="html"><![CDATA[<h1 id="js中定义变量的方法"><a href="#js中定义变量的方法" class="headerlink" title="js中定义变量的方法"></a>js中定义变量的方法</h1><h2 id="1、var"><a href="#1、var" class="headerlink" title="1、var"></a>1、var</h2><blockquote><p>基于var创建一个的变量叫N的值，让其指向具体的的值10</p></blockquote><pre><code>var n=10;console.log(10); // =&gt;10</code></pre><h2 id="2、let"><a href="#2、let" class="headerlink" title="2、let"></a>2、let</h2><blockquote><p>基于ES6中的Let创建的一个变量，让其指向100，但后期让其重新指向了一个新值200</p></blockquote><pre><code>let a=100;    a=200;console.log(a); // =&gt;200</code></pre><h2 id="3、const"><a href="#3、const" class="headerlink" title="3、const"></a>3、const</h2><blockquote><p>基于ES6中的const创建一个变量，让其指向1000，但后期让其指向2000，会报错，因此const创建的值是不能改变，所以const是常量</p></blockquote><pre><code>const b=1000;      b=2000;console.log(b); // =&gt;TypeError: Assignment to constant variable.</code></pre><h2 id="4、function"><a href="#4、function" class="headerlink" title="4、function"></a>4、function</h2><blockquote><p>创建一个函数，也可以理解为创建了一个fun，让其指向这个函数</p></blockquote><pre><code>function fun()&#123;&#125;;conosle.log(fun); // =&gt;ƒ fun() &#123;&#125;</code></pre><h2 id="5、class类"><a href="#5、class类" class="headerlink" title="5、class类"></a>5、class类</h2><blockquote><p>创建一个类也可以理解创建了一个变量Parent,让其指向这个类</p></blockquote><pre><code>class Parent&#123;&#125;;cosnole.log(Parent); // =&gt; class Parent &#123; &#125;</code></pre><h2 id="6、import-require"><a href="#6、import-require" class="headerlink" title="6、import/require"></a>6、import/require</h2><blockquote><p>基于模块规范来导入具体的某个模块，定义一个axios的变量，用来指向导入的这个模块</p></blockquote><pre><code>// 导入axios模块import axios from &#39;axios&#39;;// 导入axios模块let axios=require(&#39;./axions&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序的对云数据库的增删改查</title>
      <link href="/posts/micrud/"/>
      <url>/posts/micrud/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序的对云数据库的增删改查"><a href="#微信小程序的对云数据库的增删改查" class="headerlink" title="微信小程序的对云数据库的增删改查"></a>微信小程序的对云数据库的增删改查</h1><h2 id="创建数据的类型"><a href="#创建数据的类型" class="headerlink" title="*创建数据的类型"></a>*创建数据的类型</h2><table><thead><tr><th align="center">类型</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">Bumber</td><td align="center">字符串类型  ‘a’ ,’b’</td></tr><tr><td align="center">Number</td><td align="center">数值类型  0 1 2 3</td></tr><tr><td align="center">Boolean</td><td align="center">布尔值类型  true || false</td></tr><tr><td align="center">Object</td><td align="center">对象类型 obj:{num:1,name:’哈利波特’}</td></tr><tr><td align="center">Null</td><td align="center">空值</td></tr><tr><td align="center">Array</td><td align="center">数组  list:[‘item1’,’item2]</td></tr><tr><td align="center">Date</td><td align="center">时间类型</td></tr><tr><td align="center">Geopoint</td><td align="center">位置类型</td></tr></tbody></table><h2 id="一、查询数据"><a href="#一、查询数据" class="headerlink" title="一、查询数据"></a>一、查询数据</h2><h4 id="1、云函数查询数据库数据"><a href="#1、云函数查询数据库数据" class="headerlink" title="1、云函数查询数据库数据"></a>1、云函数查询数据库数据</h4><pre><code>// 文件名称为getData    // 云函数入口文件    const cloud=require(&#39;wx-server-sdk&#39;);    // 初始化    cloud.init()    // 连接数据库    const db=cloud.database();    导出数据    exports.main = async (event, context) =&gt;&#123;        // 查询数据库数据并返回        return await db.collection(&#39;数据库名称&#39;).get()    &#125;</code></pre><h4 id="2、本地查询数据库数据"><a href="#2、本地查询数据库数据" class="headerlink" title="2、本地查询数据库数据"></a>2、本地查询数据库数据</h4><pre><code>// 调用云函数数据wx.cloud.callection(&#123;    // 云函数名称    name:&#39;getData&#39;&#125;).then(res=&gt;&#123;    console.log(res)&#125;)-------------------------------------------//本地查询数据库数据    // 连接数据库    const db=wx.cloud.database()    // 查询数据    db.collection(&#39;数据库名称&#39;).get().then(res=&gt;&#123;        console.log(res)    &#125;)</code></pre><h2 id="二、添加数据"><a href="#二、添加数据" class="headerlink" title="二、添加数据"></a>二、添加数据</h2><h4 id="1、云函数添加数据"><a href="#1、云函数添加数据" class="headerlink" title="1、云函数添加数据"></a>1、云函数添加数据</h4><pre><code>// 文件名为 getData// 云函数入口文件const cloud = require(&#39;wx-server-sdk&#39;)// 初始化cloud.init()// 连接数据库const db = cloud.database()// 云函数入口函数exports.main = async (event, context) =&gt; &#123;// 将添加完的数据返回到本地  return await db.collection(&#39;数据库名称&#39;).add(&#123;  // 要创建的数据    data: &#123;     name:&#39;哈利波特&#39;,     age:20,     sex:&#39;男&#39;，     marriage：false    &#125;  &#125;)&#125; </code></pre><h4 id="2、本地添加数据和调用云函数"><a href="#2、本地添加数据和调用云函数" class="headerlink" title="2、本地添加数据和调用云函数"></a>2、本地添加数据和调用云函数</h4><pre><code>// 调用云函数创建的数据 wx.cloud.callFunction(&#123; // 云函数名称 name:&#39;getData&#39; &#125;).then(res=&gt;&#123;     conosle.log(res)   &#125;)--------------------------------------------------------- // 本地向数据库添加用户 // 本地连接数据库    const db=wx.cloud.database();    db.collection(&#39;数据库名称&#39;).add(&#123;        // 要创建的数据        data: &#123;         name:&#39;哈利波特&#39;,         age:20,         sex:&#39;男&#39;，         marriage：false        &#125;    &#125;).then(res=&gt;&#123;        console.log(res)    &#125;)</code></pre><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>​    在云函数中添加数据是没有用户的openid的,在本地创建的数据自带用户openid</p><h2 id="三、删除数据"><a href="#三、删除数据" class="headerlink" title="三、删除数据"></a>三、删除数据</h2><h4 id="1、云函数删除数据库数据"><a href="#1、云函数删除数据库数据" class="headerlink" title="1、云函数删除数据库数据"></a>1、云函数删除数据库数据</h4><pre><code>// 文件名为delDataconst cloud=require(wx-server-sdk);//初始化cloud.init();const db=cloud.database();exports.main= async (event,context)=&gt;&#123;    // 删除数据库数据并返回    return await db.collection(&#39;数据库名字&#39;).doc(&#39;要删除数据的id&#39;).remove()&#125;</code></pre><h4 id="2、-本地删除数据库数据和调用云函数"><a href="#2、-本地删除数据库数据和调用云函数" class="headerlink" title="2、 本地删除数据库数据和调用云函数"></a>2、 本地删除数据库数据和调用云函数</h4><pre><code>// 调用云函数删除数据wx.cloud.callFuction(&#123;    // 要删除的问函数名称    name:&#39;delData&#39;&#125;).then(res=&gt;&#123;    console.log(res)&#125;)-----------------------------------------------------// 本地删除数据库数据、    //连接数据库    const db=wx.cloud.database();    db.collection(&#39;text&#39;).doc(&#39;要删除的数据id&#39;).remove().then(res=&gt;&#123;        console.log(res)    &#125;)</code></pre><h6 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h6><p>本地删除操作默认只能删除自己在本地创建的数据，不能删除云开发控制台和云函数中常见的数据，如：需求是在本地删除数据，请在云控制台中的数据库修改权限</p><h2 id="四、修改数据"><a href="#四、修改数据" class="headerlink" title="四、修改数据"></a>四、修改数据</h2><h4 id="1、-云函数中修改数据"><a href="#1、-云函数中修改数据" class="headerlink" title="1、 云函数中修改数据"></a>1、 云函数中修改数据</h4><pre><code>// 文件名为updateDataconst cloud=require(&#39;wx-server-sdk&#39;);cloud.init()const db=cloud.database()exports.main= async (event, context) =&gt; &#123;    // 修改部分数据并返回    return await db.collection(&#39;数据库名称&#39;).doc(&#39;要修改的数据id&#39;).update(&#123;    // 要修改的值        data:&#123;            name:&#39;赫敏&#39;，            age:30        &#125;    &#125;)&#125;</code></pre><h4 id="2、本地修改数据库数据和调用云函数"><a href="#2、本地修改数据库数据和调用云函数" class="headerlink" title="2、本地修改数据库数据和调用云函数"></a>2、本地修改数据库数据和调用云函数</h4><pre><code>// 调用云函数wx.cloud.callection(&#123;    name:&#39;updateData&#39;&#125;).then(res=&gt;&#123;    console.log(res)&#125;)--------------------------------------------// 本地修改数据库数据const db=wx.cloud.database();db.collection(&#39;数据库名称&#39;).doc(&#39;要修改的数据id&#39;).update(&#123;    // 要修改的数据    data:&#123;        name:&#39;卢娜&#39;，        age:30    &#125;&#125;).then(res=&gt;&#123;    console.log(res)&#125;)</code></pre><h6 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h6><p>  本地调用和云函数的区别只在于</p><ul><li>云函数权限大</li><li>本地操作要在代码前要添加wx.什么什么</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node将明文密码加密</title>
      <link href="/posts/nobcrypt/"/>
      <url>/posts/nobcrypt/</url>
      
        <content type="html"><![CDATA[<h3 id="今天给大家介绍一款Node密码加密的模块-bcrypt"><a href="#今天给大家介绍一款Node密码加密的模块-bcrypt" class="headerlink" title="今天给大家介绍一款Node密码加密的模块 bcrypt"></a>今天给大家介绍一款Node密码加密的模块 bcrypt</h3><ol><li><h5 id="使用bcrypt模块加密前确保本机存在python环境"><a href="#使用bcrypt模块加密前确保本机存在python环境" class="headerlink" title="使用bcrypt模块加密前确保本机存在python环境"></a>使用bcrypt模块加密前确保本机存在python环境</h5><p><a href="https://www.python.org/">python官网</a></p></li><li><h5 id="下载bacrypt模块"><a href="#下载bacrypt模块" class="headerlink" title="下载bacrypt模块"></a>下载bacrypt模块</h5><pre><code>npm install bcrypt</code></pre></li><li><h5 id="在本地项目中导入bcrypt模块"><a href="#在本地项目中导入bcrypt模块" class="headerlink" title="在本地项目中导入bcrypt模块"></a>在本地项目中导入bcrypt模块</h5><pre><code>const bcrypt = require(&#39;bcrypt&#39;)</code></pre></li><li><h5 id="生成盐-（理论下值于高，越不容易被破解）"><a href="#生成盐-（理论下值于高，越不容易被破解）" class="headerlink" title="生成盐  （理论下值于高，越不容易被破解）"></a>生成盐  （理论下值于高，越不容易被破解）</h5><pre><code>const salt = await bcrypt.genSalt(10) /*  * 注意:  *      1、生成的盐是异步操作  *      2、数值表示加密的强度 0-10  */ </code></pre></li><li><h5 id="将密码进行加密处理"><a href="#将密码进行加密处理" class="headerlink" title="将密码进行加密处理"></a>将密码进行加密处理</h5><pre><code>const newPass=await bcrypt.hash(pass,salt)/* * 注意 *   1、 加密密码是异步操作 *   2、salt是第四步生生成的盐，pass是要加密的值，newPass是加密后的新密码 */</code></pre></li><li><h5 id="验证密码是否加密成功"><a href="#验证密码是否加密成功" class="headerlink" title="验证密码是否加密成功"></a>验证密码是否加密成功</h5><pre><code>const isOk= await bcrypt.compare(newPass,pass)console.log(isok) // false || true/* * 注意: *   1、验证密码是异步操作 *   2、新密码与旧密码比对，如果成功返回true,失败返回false */</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> bcrypt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript关于数组方法</title>
      <link href="/posts/jsarraymethod/"/>
      <url>/posts/jsarraymethod/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript关于数组方法"><a href="#javascript关于数组方法" class="headerlink" title="javascript关于数组方法"></a>javascript关于数组方法</h1><h3 id="Array-forEach-v-i"><a href="#Array-forEach-v-i" class="headerlink" title="Array.forEach(v, i)"></a>Array.forEach(v, i)</h3><ol><li>作用 :循环数组</li><li>形参：</li></ol><ul><li><p>v : 当前循环项</p></li><li><p>i :  当前循环项索引</p></li></ul><pre><code>const array = [    &#123;    id:0,    name:&#39;孙为空&#39;    &#125;,    &#123;    id:1,    name:&#39;猪八戒&#39;    &#125;,    &#123;    id:2,    name:&#39;沙悟净&#39;    &#125;,    &#123;    id:3,    name:&#39;唐三藏&#39;    &#125;]array.forEach((v,i)=&gt;&#123;    consoel.log(v,i)&#125;)// 输出:&#123;id:0,name:&#39;孙悟空&#39;&#125;,&#123;id:1,name:&#39;猪八戒&#39;&#125;,&#123;id:2,name:&#39;沙悟净&#39;&#125;,&#123;id:3,name:&#39;唐三藏&#39;&#125;</code></pre><h3 id="Array-filter-v-i"><a href="#Array-filter-v-i" class="headerlink" title="Array.filter(v, i)"></a>Array.filter(v, i)</h3><ol><li>作用 : 过滤数组,并返回新数组</li><li>形参：</li></ol><ul><li>v : 当前循环项</li><li>i :  当前循环项索引</li></ul><pre><code>const num = [10,15,20,25]const newNum = num.filter((v,i)=&gt;&#123;    return v &gt;= 15&#125;)console.log(newNum)//输出:    [15, 20, 25]</code></pre><h3 id="Array-map-v-i"><a href="#Array-map-v-i" class="headerlink" title="Array.map(v, i)"></a>Array.map(v, i)</h3><ol><li>作用 : 返回数组中指定的值</li><li>形参：*同上</li></ol><pre><code>const list = [    &#123;     name:&#39;张三&#39;,     age:20    &#125;,    &#123;     name:&#39;李四&#39;,     age:25    &#125;,    &#123;     name:&#39;王五&#39;,     age:27    &#125;]const newList = list.map((v,i)=&gt;&#123;    return v.name&#125;)console.log(newList)// 输出:    [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</code></pre><h3 id="Array-findIndex-v-i"><a href="#Array-findIndex-v-i" class="headerlink" title="Array.findIndex(v, i)"></a>Array.findIndex(v, i)</h3><ol><li>作用 : 返回符合条件的索引 </li><li>形参：*同上</li><li>注意：如果找到符合条件的值，立即结束循环并返回索引</li><li>索引：索引是从0开始计算的</li></ol><pre><code>const num = [10,20,30,40]const index = num.findIndex((v,i)=&gt;&#123;    return v &gt; 25&#125;)console.log(index)// 输出:    2</code></pre><h3 id="Array-every-v-i"><a href="#Array-every-v-i" class="headerlink" title="Array.every(v, i)"></a>Array.every(v, i)</h3><ol><li>作用 : 判断数组中的值符合条件，并返回布尔值 false || true</li><li>形参：*同上</li><li>注意：数组中只要有一个不符合条件，都会返回false,并立即结束循环</li></ol><pre><code>const num = [20,30,40,50]const bool = num.every((v,i)=&gt;&#123;    console.log(v)    return v &lt;= 30&#125;)console.log(bool)// 输出:    20    30    40    false</code></pre><h3 id="Array-some-v-i"><a href="#Array-some-v-i" class="headerlink" title="Array.some(v, i)"></a>Array.some(v, i)</h3><ol><li>作用 : 判断数组中的值符合条件，并返回布尔值 false || true</li><li>形参：*同上</li><li>注意：数组中只要有一个符合条件，都会返回true,并立即结束循环</li></ol><pre><code>const num = [10,20,30,40]const bool=num.some((v,i)=&gt;&#123;    console.log(v)    return v&gt;=30&#125;)console.log(bool)// 输出:    10    20    30    true</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb数据加密</title>
      <link href="/posts/modb/"/>
      <url>/posts/modb/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>打开终端</strong> （如：cmd || powershell 等等…）</p></li><li><p>输入  <strong>mongo</strong></p></li><li><p><strong>show dbs</strong>   //查询数据列表</p></li><li><p><strong>use admin</strong>  //切换至admin数据库</p></li><li><p><strong>db.createUser({user:’用户名’，pwd:’设置管理员密码’，roles:[‘root’]})</strong>  //创建超级管理员</p><ol><li><p>role: 管理权限</p></li><li><p>参数：</p><ul><li><p>root:超级管理员权限，可对任意数据库进行增删改查</p></li><li><p>read能读取该数据库的内容，但不能进心修改</p></li><li><p>readwrite:   可以对该数据库进行增删改查</p></li></ul></li></ol></li><li><p><strong>use text</strong>   //创建并进入text数据库</p></li><li><p><strong>db.createUser({user:’用户名‘，pwd:’密码’，roles:[‘readWhite’]})</strong>        //创建普通管理员</p><pre><code>// 创建代码    db.createUser(&#123;user:&#39;text&#39;,pwd:&#39;teal&#39;,roles:[&#39;readWrite&#39;]&#125;)// 成功提示    Successfully added user: &#123; &quot;user&quot; : &quot;text&quot;, &quot;roles&quot; : [ &quot;readWrite&quot; ] &#125;</code></pre></li><li><p><strong>edit</strong>  //退出</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
