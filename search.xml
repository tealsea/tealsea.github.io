<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈内存与堆内存</title>
      <link href="//jsstack/"/>
      <url>//jsstack/</url>
      
        <content type="html"><![CDATA[<h1 id="栈内存与堆内存"><a href="#栈内存与堆内存" class="headerlink" title="栈内存与堆内存"></a>栈内存与堆内存</h1><h2 id="内存分类"><a href="#内存分类" class="headerlink" title="内存分类"></a>内存分类</h2><ul><li>栈内存  stack</li><li>堆内存  heap </li></ul><h2 id="栈内存与堆内存区别"><a href="#栈内存与堆内存区别" class="headerlink" title="栈内存与堆内存区别"></a>栈内存与堆内存区别</h2><ol><li>栈内存是储存基本数据类型值和为执行上下文提供的环境</li><li>堆内存是存储引用数据类型的，他会在内存中开辟一条新的内存来储存值，并生成一个16进制的地址</li></ol><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h2><ul><li><p>当当浏览器中打开页面，浏览器引擎会渲染相关的代码（包含js代码），换句话说就是把代码从上往下执行</p></li><li><p>浏览器想要执行代码，会提供一个代码执行环境，(ECStack 全称 Execution Context Stack  =&gt;栈内存 Stack)</p></li><li><p>在全局的执行上下文中有一个VO(GLOBAL)全局变量对象，可以把代码中的变量和对应的值存储到这里面</p><h4 id="创建变量的顺序"><a href="#创建变量的顺序" class="headerlink" title="创建变量的顺序"></a>创建变量的顺序</h4><ul><li><p>先将值存到真内存中（值是基本类型的值）</p></li><li><p>创建一个变量 ,把变量存到VO(GLOBAL)中</p></li><li><p>让创建的变量和值进行关联在一起</p><p><img src="https://s1.ax1x.com/2020/09/05/wE9LDS.md.png" alt="创建一个变量过程图"></p></li></ul></li></ul><pre><code>    //练习    let a=12;    let b=a;        b=13;    console.log(a)</code></pre><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ul><li><p>首先浏览器创建一个会提供一个代码运行环境栈内存</p></li><li><p>在栈内存中有一个VO全局变量，来储存变量和基本数据类型的值</p></li><li><p>开始运运行代码，let a=12</p><ol><li>现在VO中创建值12</li><li>然后在创建一个变量a</li><li>最后将a和12关联在一起</li></ol></li><li><p>继续执行代码，let b=a;</p><ol><li>首先创建值a（a是一个变量，已经创建过了所以直接跳过）</li><li>创建变量b</li><li>最后将b和a关联在一起，（现在a的值是12，所以b的值也是12）</li></ol></li><li><p>继续执行代码,  b=13;</p><ol><li>将b的值重新赋值为13</li><li>因一个变量只能指向同一个变量所以切断了和a的关联（也就是12）</li></ol></li><li><p>最后代码输出 ， console.log(a)</p><ul><li>此时可以得出a还是那个值12，而b的值已经变为了13</li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/09/05/wAXiRS.md.png" alt="代码执行过程图"></p><pre><code>//练习let n=&#123;    name:&#39;teal&#39;&#125;;let m=n;m.name=&#39;red&#39;;console.log(a.name);</code></pre><h4 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h4><ul><li><p>首先浏览器提供一个代码执行环境栈内存</p></li><li><p>在栈内存中有一个VO全局变量存储</p></li><li><p>代码执行 ，let n={name:’teal’}</p><ol><li>首先创建值，因创建的值不是基本数据类型，所以在内存中开辟一个堆内存，堆内存的地址为AAAFFF111</li><li>在VO中存储堆内存的地址</li><li>创建一个变量n</li><li>让变量n指向这个堆内存的地址</li></ol></li><li><p>代码继续执行，let m=n;</p><ol><li>创建值n,因n是一个变量已经被创建，所以跳过</li><li>创建变量b</li><li>让变量b和变量a关联(也是执行堆内存的地址)</li></ol></li><li><p>代码继续执行， m.name=’red’</p><ol><li>让变量m中的name属性重新赋值为:‘red’</li><li>此时m和n是执行的是同一个堆内存地址，所以堆内存中的nama属性值变为了：’red’</li></ol></li><li><p>最后输出代码值，console.log(n,name);</p><ol><li>此时n.name的值不再是 ‘teal’,而是新值 ’red‘</li></ol></li></ul><p><img src="https://s1.ax1x.com/2020/09/05/wAXPG8.md.png" alt="代码执行过程图"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面试题一</title>
      <link href="//jswor/"/>
      <url>//jswor/</url>
      
        <content type="html"><![CDATA[<h1 id="栈内存与堆内存"><a href="#栈内存与堆内存" class="headerlink" title="栈内存与堆内存"></a>栈内存与堆内存</h1><h1 id="js练习面试题一"><a href="#js练习面试题一" class="headerlink" title="js练习面试题一"></a>js练习面试题一</h1><h2 id="一、问答题"><a href="#一、问答题" class="headerlink" title="一、问答题"></a>一、问答题</h2><ol><li><h3 id="js中常用的数据类型都有哪些？"><a href="#js中常用的数据类型都有哪些？" class="headerlink" title="js中常用的数据类型都有哪些？"></a>js中常用的数据类型都有哪些？</h3><blockquote><h4 id="基本数据类型：string-number-boolean-null-undefined-symbol-bigint"><a href="#基本数据类型：string-number-boolean-null-undefined-symbol-bigint" class="headerlink" title="基本数据类型：string number boolean null undefined symbol bigint"></a>基本数据类型：string number boolean null undefined symbol bigint</h4><h4 id="引用数据类型："><a href="#引用数据类型：" class="headerlink" title="引用数据类型："></a>引用数据类型：</h4><h5 id="object-普通对象-数组对象-正则对象"><a href="#object-普通对象-数组对象-正则对象" class="headerlink" title="object: 普通对象  数组对象  正则对象"></a>object: 普通对象  数组对象  正则对象</h5><h5 id="function"><a href="#function" class="headerlink" title="function"></a>function</h5></blockquote></li><li><h3 id="浏览器中常用的内核有哪些？"><a href="#浏览器中常用的内核有哪些？" class="headerlink" title="浏览器中常用的内核有哪些？"></a>浏览器中常用的内核有哪些？</h3><blockquote><h4 id="Webkit内核、Gecko内核、Trident内核、Blink内核"><a href="#Webkit内核、Gecko内核、Trident内核、Blink内核" class="headerlink" title="Webkit内核、Gecko内核、Trident内核、Blink内核"></a>Webkit内核、Gecko内核、Trident内核、Blink内核</h4></blockquote></li><li><h3 id="数据类型直接的区别？"><a href="#数据类型直接的区别？" class="headerlink" title="数据类型直接的区别？"></a>数据类型直接的区别？</h3><blockquote><h4 id="基本数据类型存储在栈内存中，而引用数据类型存储在堆内存中"><a href="#基本数据类型存储在栈内存中，而引用数据类型存储在堆内存中" class="headerlink" title="基本数据类型存储在栈内存中，而引用数据类型存储在堆内存中"></a>基本数据类型存储在栈内存中，而引用数据类型存储在堆内存中</h4></blockquote></li><li><h3 id="列举常用的关键字和保留字"><a href="#列举常用的关键字和保留字" class="headerlink" title="列举常用的关键字和保留字"></a>列举常用的关键字和保留字</h3><blockquote><p><strong>关键字</strong>：break、else、new、var、case、finally，return，void、catch、for、switch、while、continue、function、this、with、default、if、throw、delete、in、try、do、instanceof、typeof</p><p><strong>保留字</strong>：abstract、enum、int 、short、boolean、export、interface、static、byte、extends、long、super、char、final、native、synchronized、class、float、package、throws、const、goto、private、transient、debugger、implements、protected、volatile、double、import、public</p></blockquote></li><li><h3 id="js中创建变量的几种常用方式？"><a href="#js中创建变量的几种常用方式？" class="headerlink" title="js中创建变量的几种常用方式？"></a>js中创建变量的几种常用方式？</h3><blockquote><p>var   </p><p>let</p><p>const </p><p>class</p><p>function</p><p>import</p></blockquote></li></ol><h2 id="二、练习题"><a href="#二、练习题" class="headerlink" title="二、练习题"></a>二、练习题</h2><ol><li><h3 id="写出下面结果输出答案（阿里面试题）"><a href="#写出下面结果输出答案（阿里面试题）" class="headerlink" title="写出下面结果输出答案（阿里面试题）"></a>写出下面结果输出答案（阿里面试题）</h3><pre><code>let a=&#123;    n:1&#125;;let b=a;a.x=a=&#123;    n:2&#125;;console.log(a.x);// undefinedconsole.log(b); // &#123;n:1,x:&#123;n:2&#125;&#125;</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p><strong>考试点：连等号的运用</strong></p><p><strong>分析图</strong></p><p><img src="https://s1.ax1x.com/2020/09/05/wVC3Tg.md.png" alt="解题过程图"></p></li><li><h3 id="分别写出下列表式输出的结果（腾讯面试题）"><a href="#分别写出下列表式输出的结果（腾讯面试题）" class="headerlink" title="分别写出下列表式输出的结果（腾讯面试题）"></a>分别写出下列表式输出的结果（腾讯面试题）</h3><pre><code>var a=&#39;abc&#39;+123+456; // =&gt;加号不经有数学运算还有字符串的拼接,只要字符串中有非法数字，就直接进行字符串拼接var b=&#39;456&#39;-&#39;123&#39;; // =&gt;将字符串中内容转换为数字类型( 456-123 )，在进行数学运算var c=100+true+21.2+null+undefined+&#39;Tencent&#39;+[]+null+9+false; // =&gt;看到加号先将字符串转换为数字(100+1+21.2+null+NaN+&#39;Tencent&#39;+&#39;&#39;+&#39;null&#39;+&#39;9&#39;+&#39;false&#39;),看到转换后为NaN的后面的不会再转数字类型，而是转字符串，然后在进行字符串拼接console.log(a);//&quot;abc123456&quot;console.log(b);//333console.log(c);//&quot;NaNTencentnull9false&quot;</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p><strong>考点：</strong>字符串的拼接及类型间的转换</p></li></ol><ol start="2"><li><h3 id="写出下列代码的输出结果（腾讯面试题）"><a href="#写出下列代码的输出结果（腾讯面试题）" class="headerlink" title="写出下列代码的输出结果（腾讯面试题）"></a>写出下列代码的输出结果（腾讯面试题）</h3><pre><code>var str=&#39;abc123&#39;;var num=parseInt(str); // =&gt;parseInt()转换规则和Number()不一样,他是先将内容(非数字内容)转换为字符串，从字符串左边开始查找，把找到的有效数字转换为数字，一直到非有效数字字符为止，则结束查找。如开始就是非有效数字直接转换为数字NaNif(num==NaN)&#123; // =&gt;NaN和任何数都不想等    alert(NaN);&#125;else if(num==123)&#123;    alert(123);&#125;else if(typeof num==&#39;number&#39;)&#123;   // =&gt;typeof 输出的值都会被转换为字符串    alert(&#39;number&#39;); //正确的输出结果&#125;else&#123;    alert(&#39;str&#39;);&#125;;</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p><strong>考点：</strong>parseInt()转换规则  </p></li></ol><ol start="3"><li><h3 id="写出下列代码的输出结果（腾讯面试题）-1"><a href="#写出下列代码的输出结果（腾讯面试题）-1" class="headerlink" title="写出下列代码的输出结果（腾讯面试题）"></a>写出下列代码的输出结果（腾讯面试题）</h3><pre><code>var a=0;var b=a;b++;alert(a);var o=&#123;&#125;;o.a=0;var c=o;c.a=10;alert(o.a);</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p><strong>考点：</strong> 基本数据类型和引用数据类型的区别</p><p><strong>分析图</strong></p><p><img src="https://s1.ax1x.com/2020/09/05/wVelnA.md.png" alt="分析过程图"></p></li></ol><ol start="4"><li><h3 id="下列输出”1”的有哪些？"><a href="#下列输出”1”的有哪些？" class="headerlink" title="下列输出”1”的有哪些？"></a>下列输出”1”的有哪些？</h3><pre><code>A:alert(1) // &quot;1&quot; =&gt;alert输出的内容都会被转换为字符串B:console.log(parseInt(1.3)); // 1  =&gt;parseInt会将非数字转换为字符串，然后将有自左向右按个查找有效数字，一直遇到非有效数字停止检查，然后将有效数字转换为数字类型C:console.log(1);//1 =&gt;consoel.log输出的是值原本的类型不会被转换D:console.log(isNaN(1));// false =&gt;isNaN检测内容是否为NaN,它会将非数字类型，通过Number转换为数字类型，是NaN输出true,不是NaN输出falseE:console.log(parseInt(&quot;1&quot;)); // 1答案：A</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：parsrInt()转换  isNaN()判断</p></li></ol><ol start="5"><li><h3 id="下面结果是”undefined”的是"><a href="#下面结果是”undefined”的是" class="headerlink" title="下面结果是”undefined”的是"></a>下面结果是”undefined”的是</h3><pre><code>A:console.log(alert(1));// undefined =&gt;先输出alert的值(&quot;1&quot;),然后将alert执行后的返回值在控制台输出，而alert没有返回值B:typeof undefined // &quot;undefined&quot; =&gt;typeof输出的值类型都会被转换为字符串C:console.log(parseInt(undefined));// NaN =&gt;先将undefined转换为数字类型(NaN)，然后在进行输出D:isNaN(undefined);// true  =&gt;先将undefined通过Number转换为最后NaN,最后判断是否为NaN答案：B</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：typeof 输出结果类型  嵌套输出结果</p></li></ol><ol start="6"><li><h3 id="下面结果能得到true的是"><a href="#下面结果能得到true的是" class="headerlink" title="下面结果能得到true的是"></a>下面结果能得到true的是</h3><pre><code>A:isNaN(null); // false =&gt;先将null通过Number转换为数字类型(0),在判断是否为NaNB:isNaN(parseInt(null));// true =&gt;parseInt先将null转换字符串，然后将有效数字转换为数字类型(NaN),然后判断是否为NaNC:Number(null);// 0 =&gt;直接将内容转换为数字类型(0)D:parseFloat(null);// NaN //将内容转换为字符串然后将有效字符转换为数字类型(NaN)答案:B</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：isNaN判断  parseInt转换  Number转换  parseFloat转换</p></li></ol><ol start="7"><li><h3 id="输出下面程序的结果"><a href="#输出下面程序的结果" class="headerlink" title="输出下面程序的结果"></a>输出下面程序的结果</h3><pre><code>parseInt(&quot;&quot;);// NaN =&gt;将内容转换为字符串，然后将有效字符转换为数字类型(NaN)Number(&quot;&quot;);// 0 =&gt;将内容直接转换为数字类型(0)isNaN(&quot;&quot;);// false =&gt;先将内容转换数字类型(0),然后在判断是否为NaNparseInt(null);// NaN =&gt;将内容转换为字符串，然后自左往右查询有效数字，一直遇到非有效数字为止，结束查询，将有效数字转换为数字类型(NaN)Number(null);// 0 =&gt; 直接将转换为数字类型(0)isNaN(null);// false =&gt;直接转换为数字内容(0),然后判断是否为NaNuparseInt(&quot;12px&quot;);// 12 =&gt;先将内容转化为字符串然后自左往右查询，一直查询到非有效数字为止，结束查询。将有效数字转换为数字类型(12)Number(&#39;12px&#39;);// NaN =&gt;直接内容转换为数字类型(NaN)isNaN(&quot;12px&quot;);//true =&gt;直接将内容转换为数字类型(NaN),然后判断是否为NaN</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：各数据类型间的数据转换</p></li></ol><ol start="8"><li><h3 id="下面程序数据的结果"><a href="#下面程序数据的结果" class="headerlink" title="下面程序数据的结果"></a>下面程序数据的结果</h3><pre><code>if(isNaN(NaN)==&quot;&quot;)&#123;     // =&gt;先判断是否为NaN(true),=&gt; true==&quot;&quot; ,然后将true转化为字符串,在进行比对    console.log(&#39;teal&#39;);&#125;else&#123;    console.log(&#39;red&#39;); // &quot;red&quot;&#125;;</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点：相等和全等</p></li></ol><ol start="9"><li><h3 id="下面程序的输出的结果"><a href="#下面程序的输出的结果" class="headerlink" title="下面程序的输出的结果"></a>下面程序的输出的结果</h3><pre><code>let x=[1,2,3];let y=x;let z=[4,5,6];y[0]=10;y=z;z[1]=20;x[2]=z=30;console.log(x,y,z)</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>考点： 栈与堆内存</p><p>分析图</p><p><img src="https://s1.ax1x.com/2020/09/05/wVYgdU.md.png" alt="分析过程图"></p></li></ol><ol start="10"><li><h2 id="下面程序的输出结果（阿里面试题）"><a href="#下面程序的输出结果（阿里面试题）" class="headerlink" title="下面程序的输出结果（阿里面试题）"></a>下面程序的输出结果（阿里面试题）</h2><pre><code>let a=&#123;    n:1&#125;;let b=a;a.x=a=&#123;    n:2&#125;;conosle.log(a.x);console.log(b)</code></pre><blockquote><p><strong>解析：</strong></p></blockquote><p>分析图</p><p><img src="https://s1.ax1x.com/2020/09/05/wVtbXq.md.png" alt="分析过程图"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中boolean数据类型</title>
      <link href="//jsboolean/"/>
      <url>//jsboolean/</url>
      
        <content type="html"><![CDATA[<h1 id="js中boolean数据类型"><a href="#js中boolean数据类型" class="headerlink" title="js中boolean数据类型"></a>js中boolean数据类型</h1><h2 id="将其他数据类型转换为布尔类型"><a href="#将其他数据类型转换为布尔类型" class="headerlink" title="将其他数据类型转换为布尔类型"></a>将其他数据类型转换为布尔类型</h2><ul><li>Boolean([value])</li><li>![value]; 把指定的值转换为布尔类型，在取反</li><li>!![value]; 把指定的值转换为布尔类型然后取反在取反（相当于将指定的值转换为布尔类型而已）</li></ul><blockquote><p>规则：只有 “ 0  NaN  null undefined  空字符串 “最后会转换为false ,其余都为true</p></blockquote><pre><code>conosle.log(!!-1); // =&gt;trueconsole.log(!!0); // =&gt;falseconsole.log(!!undefined); // =&gt;falseconsole.log(!!Number(&#39;12px&#39;)); // =&gt;falseconsole.log(!![]); // =&gt;trueconsole.log(!! &#39;&#39;); // =&gt;falseconsole.log(!!&#123;&#125;); // =&gt;true</code></pre><blockquote><p>条件判断中，每一个条件最后都会被转换为 true || false</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> boolean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中Object数据类型</title>
      <link href="//jsobject/"/>
      <url>//jsobject/</url>
      
        <content type="html"><![CDATA[<h1 id="js中object数据类型"><a href="#js中object数据类型" class="headerlink" title="js中object数据类型"></a>js中object数据类型</h1><h2 id="所有的对象都具备的特点"><a href="#所有的对象都具备的特点" class="headerlink" title="所有的对象都具备的特点"></a>所有的对象都具备的特点</h2><ol><li><p>用键值对（key:value俗称属性和属性值）来描述一个对象的特征（每一个对象都会综合体,存在零到多个键值对）</p></li><li><p>{[key:value,…]}每一组键值对是key:value的格式，多组键值对用逗号分隔</p></li><li><p>key不能是引用数据类型，value可以是任意数据类型</p><pre><code>let obj=&#123;    name:&#39;teal&#39;,    age:20,    hobby:[&#39;吃饭&#39;,&#39;睡觉&#39;],    skill:function()&#123;&#125;&#125;console.log(obj);&gt;&#123;name: &quot;teal&quot;, age: 20, hobby: Array(2), skill: ƒ&#125;</code></pre></li></ol><h2 id="关于对象中的键值对的增删改查"><a href="#关于对象中的键值对的增删改查" class="headerlink" title="关于对象中的键值对的增删改查"></a>关于对象中的键值对的增删改查</h2><ul><li><p>新增或修改属性和属性值</p><p>操作属性的两种方式</p><ol><li><p>对象.属性名=属性值</p></li><li><p>对象[属性名]=属性值</p><pre><code>let obj=&#123;&#125;;//新增属性console.log(obj.name=&#39;teal&#39;); // =&gt;&#39;teal&#39;console.log(obj[&#39;age&#39;]=20); // =&gt;20//修改属性值console.log(obj.age=30); // =&gt;30console.log(obj[&#39;name&#39;]=&#39;red&#39;); // =&gt;&#39;red&#39;</code></pre></li></ol></li><li><p>获取对象中的属性和属性值</p><ol><li><p>​    获取指定属性名的属性值</p><pre><code>let obj=&#123;    name:&#39;teal&#39;,    age:20&#125;console.log(obj.name); // =&gt;&quot;teal&quot;console.log(obj[&#39;age&#39;]); // =&gt;20</code></pre></li><li><p>如果指定的属性不存在，获取到的值为undefined(不会报错)</p><pre><code>let obj=&#123;&#125;;console.log(obj.name); // =&gt;undefinedconsole.log(obj[&#39;age&#39;]); // =&gt;undefined</code></pre></li><li><p>获取当前对象中所有的属性名=&gt;返回的结果包含所有属性名的数组</p><pre><code>let obj=&#123;    name:&#39;teal&#39;,    age:20,    hobby:[&#39;吃饭&#39;,&#39;睡觉&#39;]    &#125;console.log(obj); // =&gt;&#123;name: &quot;teal&quot;, age: 20, hobby: Array(2)&#125;</code></pre></li></ol></li><li><p>删除对象中指定的属性</p><ol><li><p>假删除：当前属性还存在，只不过属性值为空</p><pre><code>let obj=&#123;    name:&#39;teal&#39;&#125;obj.name=nullconsole.log(obj.name); // =&gt;null </code></pre></li><li><p>真删除：彻底将对象中的属性删除</p><pre><code>let obj=&#123;    name:&#39;teal&#39;&#125;;delete obj.nameconsole.log(obj[&#39;name&#39;]); // =&gt;undefined</code></pre></li></ol></li></ul><h2 id="对象中的属性名不能是引用数据类型"><a href="#对象中的属性名不能是引用数据类型" class="headerlink" title="对象中的属性名不能是引用数据类型"></a>对象中的属性名不能是引用数据类型</h2><pre><code>let n=10;let obj=&#123;&#125;;obj.n=200;// =&gt;相当于在obj中添加一个名为n的值为200的属性console.log(obj[&#39;n&#39;]); // =&gt;200obj[&#39;n&#39;]=300;// =&gt;相当于将刚创建名为n的属性值改为了300console.log(obj.n); // =&gt;300obj[n]=400;// =&gt;将创建的变量的值当作了属性名console.log(obj); // =&gt;&#123;10: 400, n: 300&#125;</code></pre><blockquote><p>n本身是一个变量（n和”n”的区别：前者是一个变量，后者是一个字符串的值），他代表的是所存储的值为100(是一个数字格式)</p></blockquote><ul><li><p>基于对象[属性名]的方式操作，需要保证属性名是一个变量（字符串  数字  布尔等都可以），如果不是值而是一个变量，他会把变量存储的值作为对象的属性名进行操作</p></li><li><p>基于对象.属性名的方式操作，属性名就是点后面的</p><pre><code>let obj=&#123;    1:100&#125;;console.log(obj[&#39;1&#39;]); // =&gt;100console.log(obj.1);//=&gt;Uncaught SyntaxError: missing ) after argument list</code></pre><blockquote><p>基于点的方式操作自己的有局限性，属性名不能是数字。此时只能用对象[属性名]的方式获取</p></blockquote></li><li><p>对象作为属性名操作的后果</p><pre><code>let n=&#123;a:20&#125;;let m=[100,200];let obj=&#123;&#125;;obj[n]=&#39;teal&#39;;// =&gt;obj[&#123;n:100&#125;]但是对象不能最为属性名，所以需要把其转换为字符串console.log(obj); // =&gt;&#123;[object Object]: &quot;teal&quot;&#125;obj[m]=100;console.log(obj); // =&gt;&#123;[object Object]: &quot;teal&quot;, 100,200: 100&#125;</code></pre></li></ul><h2 id="数组是特殊的对象"><a href="#数组是特殊的对象" class="headerlink" title="数组是特殊的对象"></a>数组是特殊的对象</h2><ol><li><p>他的属性名是数字，数字从零开始，逐级递增，每一个数字都代表当前的位置(我们将这种数字属性名称为”索引”</p></li><li><p>默认有一个length属性存储数组的长度</p><pre><code>let arr=[10,20,30];console.log(arr[0],arr[1],arr[2]);// =&gt;10,20,30console.log(arr.length); //=&gt; 3</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中typeof数据检测</title>
      <link href="//jstypeof/"/>
      <url>//jstypeof/</url>
      
        <content type="html"><![CDATA[<h1 id="js中typeof数据检测"><a href="#js中typeof数据检测" class="headerlink" title="js中typeof数据检测"></a>js中typeof数据检测</h1><h2 id="js中的数据检测"><a href="#js中的数据检测" class="headerlink" title="js中的数据检测"></a>js中的数据检测</h2><ul><li>typeof [value]; 检测数据的类型</li><li>[example] instanceof [class]; 检测数据类型</li><li>[example].constructor===[class];检测实例和类关系的，从而检测数据类型</li><li>Object.prototype.toString.call([value]);检测数据类型</li></ul><h2 id="typeof的细节点："><a href="#typeof的细节点：" class="headerlink" title="typeof的细节点："></a>typeof的细节点：</h2><ol><li><p>typeof检测的结果首先是一个字符串，字符串中包含了对应的数据类型（如：’number’、‘string’、’boolean’、’undefined’、’object’、’function’、‘symbol’、’bigint’)</p></li><li><p>特殊的检测结果；</p><ul><li><p>NaN/Infinity都是数字类型的，检测结果都为：”number”</p></li><li><p>null的结果是”object”(这是浏览器的BUG：所有的值在计算中都已二进制存储，浏览器中把前三位000的最为对象，而null的二进制前三位就是000，所以被识别为对象，但事实上他不是对象，他是对象指针，是基本数据类型）</p></li><li><p>普通对象/数组对象/正则对象都是”object”类型，这样就无法基于typeof区分普通对象还是数组对象了</p></li><li><p>检测小技巧</p><pre><code>console.log(typeof []); // =&gt;&quot;object&quot;console.log(typeof typeof typeof []); //=&gt;&quot;string&quot;</code></pre><blockquote><p>由于typeof返回的结果是一个字符串（字符串中包含了对应的类型），所以连续出现两次及两次以上的typeof检测的结果都是“string”</p></blockquote></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> typeof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中关于String数据类型</title>
      <link href="//jsstring/"/>
      <url>//jsstring/</url>
      
        <content type="html"><![CDATA[<h1 id="js中关于String数据类型"><a href="#js中关于String数据类型" class="headerlink" title="js中关于String数据类型"></a>js中关于String数据类型</h1><blockquote><p>在js中用 ：单引号 双引号  反引号 包起来的都是字符串</p></blockquote><h2 id="把其他类型的值转换为字符串类型"><a href="#把其他类型的值转换为字符串类型" class="headerlink" title="把其他类型的值转换为字符串类型"></a>把其他类型的值转换为字符串类型</h2><ul><li>String([value])</li><li>[value].toString()</li></ul><blockquote><p>普通对象转换为字符串都是 ：”[object object]”</p><p>数组对象转换为字符串是 ：”第一项，第二项，…” ; // =&gt;(以逗号分隔数组中的每一项)</p></blockquote><h2 id="在js中常用的数学运算"><a href="#在js中常用的数学运算" class="headerlink" title="在js中常用的数学运算"></a>在js中常用的数学运算</h2><ul><li><p>数学运算：+  -  *  /     //=&gt;加减乘除</p></li><li><p>％(膜) 取余数</p><pre><code>console.log(4 / 2); // =&gt;2console.log(7 / 3); // =&gt;2.3333333333333335console.log(7 % 3); // =&gt;1</code></pre></li><li><p>除了加法以外，其余的情况都是数学运算（如果遇到非数字类型，需要将其利用Number方式转换为数字类型，然后在运算）</p></li><li><p>加号在Js中既有数学运算也有字符串拼接的意思（只要加号两边的任意一边出现字符串，则变为字符串拼接）</p><pre><code>console.log(3-&#39;3px&#39;); // =&gt;NaNconsole.log(3+&#39;3px&#39;); // =&gt;&quot;33px&quot;console.log(1+&#39;1&#39;); // =&gt;&quot;11&quot;console.log(1+&#123;&#125;); // =&gt;&quot;1[object object]&quot;console.log(1+[]); // =&gt;&#39;1&#39;console.log([10]+true); // =&gt;&quot;10true&quot;  在转换为[10]到数字的过程中，先将其转换为字符串&quot;10&quot;，此后在进行字符串拼接(和数学运算没关系了)console.log(true+[10]); // =&gt;&quot;true10&quot;console.log(1+true); // =&gt;2console.log(100+true+21.2+null+undefined+&quot;tencent&quot;+[]+null+9+false); // =&gt;&quot;NaNtencentnull9falset&quot;</code></pre></li></ul><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><h3 id="传统字符串拼接"><a href="#传统字符串拼接" class="headerlink" title="传统字符串拼接"></a>传统字符串拼接</h3><pre><code>// 将下列变量拼接成 2020-09-04 12:00:00这种格式输出let year=&quot;2020&quot;;let month=&quot;09&quot;;let day=&quot;04&quot;;let hours=&quot;12&quot;;let minute=&quot;00&quot;;let second=&quot;00&quot;;let result=year+&#39;-&#39;+month+&#39;-&#39;+day+&#39; &#39;+hours+&quot;:&quot;+minute+&quot;:&quot;+second;console.log(result); // =&gt;2020-09-04 12:00:00</code></pre><h3 id="ES6模板字符串拼接"><a href="#ES6模板字符串拼接" class="headerlink" title="ES6模板字符串拼接"></a>ES6模板字符串拼接</h3><blockquote><p>es6中的模板字符串就是解决了传统字符串拼接的问题（反引号 Tab键上面的~）</p><p>${}中存方变量或其他js表达式即可，不用考虑单引号和双引号问题</p></blockquote><pre><code>// 将下列变量拼接成 2020-09-04 12:00:00这种格式输出let year=&quot;2020&quot;;let month=&quot;09&quot;;let day=&quot;04&quot;;let hours=&quot;12&quot;;let minute=&quot;00&quot;;let second=&quot;00&quot;;let result =`$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hours&#125;:$&#123;minute&#125;:$&#123;second&#125;`;console.log(result); // =&gt;2020-09-04 12:00:00</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用浏览器内核</title>
      <link href="//brower/"/>
      <url>//brower/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1、以谷歌浏览器Webkit内核为主（v8引擎）</p></blockquote><blockquote><p>2、火狐的 Gecko内核</p></blockquote><blockquote><p>3、IE浏览器的Trident内核</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的数据类型</title>
      <link href="//jsdataclass/"/>
      <url>//jsdataclass/</url>
      
        <content type="html"><![CDATA[<h1 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h1><h2 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h2><ul><li>数值 Number </li><li>字符串 String </li><li>布尔值 Boolean </li><li>空值 Null //undefined</li><li>未定义 Undefined </li><li>ES6新增的唯一的类型 Symbol</li></ul><h2 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h2><ol><li><p>对象数据类型 Object</p><ul><li>普通对象 {}</li><li>数组对象 []</li><li>正则表达式  /^$/</li><li>日期对象 new Date</li><li>数学函数对象 Math</li><li>…</li></ul><p>2、函数数据类型 Function</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中关于number的内容</title>
      <link href="//jsnumber/"/>
      <url>//jsnumber/</url>
      
        <content type="html"><![CDATA[<h1 id="关于javascript中关于number的学习内容"><a href="#关于javascript中关于number的学习内容" class="headerlink" title="关于javascript中关于number的学习内容"></a>关于javascript中关于number的学习内容</h1><h2 id="number数据类型包括那些"><a href="#number数据类型包括那些" class="headerlink" title="number数据类型包括那些"></a>number数据类型包括那些</h2><ul><li>正数、负数、浮点数、零</li><li>NaN  =&gt;NaN表示not a Number不是一个有效数字，但他属于number类型</li><li>Infinity:=&gt;表示无穷大的值 -Infinity=&gt;表示负的无穷的值</li></ul><h2 id="关于NaN"><a href="#关于NaN" class="headerlink" title="关于NaN"></a>关于NaN</h2><blockquote><p>NaN和任何数都不想等，包括他自己</p><pre><code>console.log(NaN=10); // =&gt;falseconsole.log(NaN==NaN); // =&gt;false</code></pre></blockquote><h2 id="强制将其他数据类型转换为数字"><a href="#强制将其他数据类型转换为数字" class="headerlink" title="强制将其他数据类型转换为数字"></a>强制将其他数据类型转换为数字</h2><ul><li><p>字符串：把字符串转换为数字，一旦发现字符串中出现非有效数字的字符，则结果为NaN.只有字符串中都是有效数字才能转换为具体的数字，空字符串换转换为0</p><pre><code>console.log(Number(&#39;10&#39;)); // =&gt;10console.log(Number(&#39;10px&#39;)); // =&gt;NuNconsole.log(Number()); // =&gt;0</code></pre></li><li><p>布尔值：把布尔值转换为数字=&gt; true转换为1 ，false转换为0</p><pre><code>console.log(Number(true)); // =&gt;1console.log(Number(false)); // =&gt;0</code></pre></li><li><p>空值： 把空值转换为数字=&gt; null转换为0    undefined转换为NaN</p><pre><code>console.log(Number(null)); // =&gt;0console.log(Number(undefined)); // =&gt;NaN</code></pre></li><li><p>symbol: 不能将symbol类型转换为数字，否则会报错</p><pre><code>console.log(Number(symbol)); // =&gt;Uncaught ReferenceError: symbol is not defined</code></pre></li><li><p>对象：=&gt;对象转换为数字=&gt;先把对象转换为字符串，再把字符串转换为数字</p><ol><li><p>普通对象转换为数字都为NaN</p></li><li><p>数组转换为数字，只有当数组长度为1，并且数组内的值为有效数字才能转换为对应的数字，或数组为空也可以转换为数字0，其余都转换为NaN</p><pre><code>console.log(Number([])); // =&gt;0console.log(Number([&#39;10&#39;])); // =&gt;10console.log(Number([&#39;aa&#39;])); // =&gt;NaNconsole.log(Number([10,12])); //=&gt;NaN</code></pre></li></ol></li><li><p>函数：函数转换为数字都为NaN</p><pre><code>console.log(Number(function fun()&#123;&#125;)); // =&gt;NaN</code></pre></li></ul><h2 id="Number将其他类型转换为数字的方法"><a href="#Number将其他类型转换为数字的方法" class="headerlink" title="Number将其他类型转换为数字的方法"></a>Number将其他类型转换为数字的方法</h2><ol><li>Number([value]); =&gt;而isNaN在检测是否为有效数字是就是使用的这种方法</li><li>parseInt([value]); </li><li>parsrFloat([value]);</li></ol><h2 id="检测一个数是否为NaN"><a href="#检测一个数是否为NaN" class="headerlink" title="检测一个数是否为NaN"></a>检测一个数是否为NaN</h2><blockquote><p>isNaN()=&gt;想要验证一个数是否是有效数字可以通过使用isNaN()这个方法，是有效数字返回false,不是有效数字返回true</p></blockquote><pre><code>console.log(isNaN(&#39;AA&#39;)); // =&gt; trueconsole.log(isNaN(&#39;12.5’)); // =&gt; falseconsole.log(isNaN(&#39;12.5PX&#39;)); // =&gt; trueconsole.log(isNaN([])); // =&gt; falseconsole.log(isNaN([10])); // =&gt; falseconsole.log(isNaN([10,20])); // =&gt; trueconsole.log(isNaN(&#123;&#125;)); // =&gt; trueconsole.log(isNaN(null)); // =&gt; falseconsole.log(isNaN(undefined)); // =&gt; trueconsole.log(isNaN(symbol)); // =&gt; 报错</code></pre><h2 id="parseInt-parseFloat将其他类型转换为数字"><a href="#parseInt-parseFloat将其他类型转换为数字" class="headerlink" title="parseInt/parseFloat将其他类型转换为数字"></a>parseInt/parseFloat将其他类型转换为数字</h2><ul><li>转换原理和Number转换不一样，他是把字符串转换为数字类型(如果处理的值不是字符串，需要先转换为字符串，然后再去转化为Number类型)</li><li>转换原理：从字符串左边开始查找，把找到得 有效数字转换为数字字符串转换为数字，一直遇到一个非有效数字字符为止，则结束查找</li><li>null/undefined类型都是NaN(先将null转换为普通字符串“null”在转换为数字，结果为NaN,=&gt;所有的字符都一样)</li><li>parseFloat比parseInt只是多识别一个小数点</li></ul><pre><code>console.log(parseInt(&#39;10&#39;));  // =&gt;10console.log(parseInt(&#39;10px&#39;)); // =&gt;10console.log(parseInt(&#39;wdith:20px&#39;)); // =&gt; NaNconsole.log(parseInt(&#39;12.5&#39;)); // =&gt;12console.log(parseFloat(&#39;12.5&#39;)); // =&gt;12.5console.log(parseInt(null)); // =&gt;NaNconsole.log(parseFloat(false)); // =&gt;NaN</code></pre><h2 id="最大安全数："><a href="#最大安全数：" class="headerlink" title="最大安全数："></a>最大安全数：</h2><pre><code>console.log(number_MAX_SAFE_INTEGER); //=&gt;9007199254740991 (Js中最大的安全数=&gt;Js能够识别得最大整数) console.log(9007199254740992==9007199254740993); //=&gt;true(理想结果应该是false,但超过了最大安全数，Js无法精确计算)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中常用的输出方式</title>
      <link href="//jsoutputmode/"/>
      <url>//jsoutputmode/</url>
      
        <content type="html"><![CDATA[<h1 id="js中常用的输出方式"><a href="#js中常用的输出方式" class="headerlink" title="js中常用的输出方式"></a>js中常用的输出方式</h1><h2 id="1、console控制台：在浏览器控制台输出"><a href="#1、console控制台：在浏览器控制台输出" class="headerlink" title="1、console控制台：在浏览器控制台输出"></a>1、console控制台：在浏览器控制台输出</h2><ul><li><p>console.log; =&gt;可以输出任意数据类型，控制台展示的类型也是对应的数据类型</p><pre><code>console.log(&#39;a&#39;,10,&#123;name:&#39;Teal&#39;&#125;,[10,20],false); // =&gt;a 10 &#123;name: &quot;Teal&quot;&#125; (2) [10, 20] false</code></pre></li><li><p>console.dir; =&gt;输出一个对象或一个值得详细信息</p><pre><code>console.dir(&#123;name:&#39;Teal&#39;,age:20&#125;); // =&gt;Object age: 20 name: &quot;Teal&quot; __proto__: Object</code></pre></li><li><p>console.wran; =&gt;输出一个黄色背景的提示信息</p><pre><code>cosnole.wran(&#39;当前操作不符合规范&#39;); // =&gt; 黄色背景：‘当前操作不符合规范’</code></pre></li><li><p>console.table; =&gt;将json数据转化为表格输出</p><pre><code>console.table(&#123;name:&#39;teal&#39;,age:20&#125;)// =&gt;</code></pre><table><thead><tr><th>(index)</th><th>Value</th></tr></thead><tbody><tr><td>name</td><td>“teal”</td></tr><tr><td>age</td><td>20</td></tr></tbody></table></li><li><p>console.time/timeEnd; =&gt;计算中间程序运行的预估时间（预估时间：会受到当前电脑性能的影响）</p><pre><code>console.time(&#39;a&#39;); //a表示当前计算的任务名称for(let i=0;i&lt;99999999;i++)&#123;&#125;console.timeEnd(&#39;a&#39;); // =&gt; a: 51.40185546875 ms</code></pre></li></ul><h2 id="2、window提示框"><a href="#2、window提示框" class="headerlink" title="2、window提示框"></a>2、window提示框</h2><ul><li><p>alert; =&gt;alert是浏览器窗口弹出一个提示框，提示框中输出指定的信息，但输出的是字符串</p><pre><code>alert(20); // =&gt;&quot;20&quot;</code></pre></li><li><p>config;=&gt;相对于alert来说，给用户添加了两个选择按钮，第一个就是确定按钮第二个是取消按钮，我们可以通过用户点击的按钮拿到用户点击了那个按钮</p><pre><code>const bool=confirm(&#39;是否点击&#39;);console.log(bool); // =&gt;点击按钮输出true,点击取消输出false</code></pre></li><li><p>prompt; =&gt;相对于confirm来说在提供按钮的基础上还添加了输入框供用户输入信息，我们可以通过用户点击按钮来拿到用户输入的数据</p><pre><code>const data=prompt(&#39;请输入内容&#39;);cosnole.log(date); // =&gt;如果用户点击了确定按钮就会输出用户输入的值，如果点击了取消就会输出null</code></pre></li></ul><h2 id="3、向页面写入数据"><a href="#3、向页面写入数据" class="headerlink" title="3、向页面写入数据"></a>3、向页面写入数据</h2><ul><li><p>document.write;=&gt;把内容写入到页面中</p><pre><code>document.write(123); // =&gt;&quot;123&quot;</code></pre></li><li><p>innerHTML/innerText；向指定的容器中插入信息，基于这两种方法会把原有的数据给覆盖掉，想要追加内容采用+=方式，innerHTML还可以将语义化标签解析成代码，而innerText会将其当作字符串直接输出</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ZH-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;text&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;box&quot;&gt;123&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    // 读取内容    console.log(document.querySelector(&#39;#box&#39;).innerHTML); // =&gt;&quot;123&quot;    console.log(document.querySelector(&#39;#box&#39;).innerText); //=&gt;&quot;123    //覆盖原有数据    console.log(document.querySelector(&#39;#box&#39;).innerHTML=456) // =&gt;456    console.log(document.querySelector(&#39;#box&#39;).innerText=456) // =&gt;456    //追加内容    console.log(document.querySelector(&#39;#box&#39;).innerHTML+=&#39;aaa&#39;); // =&gt;456aaa    console.log(document.querySelector(&#39;#box&#39;).innerText+=&#39;aaa&#39;); // =&gt;456aaaaaa    //渲染语义化标签    console.log(document.querySelector(&#39;#box&#39;).innerHTML=&#39;&lt;h1&gt;123&lt;/h1&gt;&#39;); // =&gt;一级标题下的123    console.log(document.querySelector(&#39;#box&#39;).innerText=&#39;&lt;h1&gt;123&lt;/h1&gt;&#39;); // =&gt;&quot;&lt;h1&gt;123&lt;/h1&gt;&quot;&lt;/script&gt;</code></pre></li><li><p>value;=&gt;给页面中的input赋值</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ZH-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;text&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   &lt;input type=&quot;text&quot; id=&quot;output&quot;&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    document.querySelector(&#39;#output&#39;).value=&#39;我是输入框中的内容&#39;; // =&gt;在输入框中有“我是输入框中的内容”这几个字&lt;/script&gt;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中定义变量的方法</title>
      <link href="//jsvariable/"/>
      <url>//jsvariable/</url>
      
        <content type="html"><![CDATA[<h1 id="js中定义变量的方法"><a href="#js中定义变量的方法" class="headerlink" title="js中定义变量的方法"></a>js中定义变量的方法</h1><h2 id="1、var"><a href="#1、var" class="headerlink" title="1、var"></a>1、var</h2><blockquote><p>基于var创建一个的变量叫N的值，让其指向具体的的值10</p></blockquote><pre><code>var n=10;console.log(10); // =&gt;10</code></pre><h2 id="2、let"><a href="#2、let" class="headerlink" title="2、let"></a>2、let</h2><blockquote><p>基于ES6中的Let创建的一个变量，让其指向100，但后期让其重新指向了一个新值200</p></blockquote><pre><code>let a=100;    a=200;console.log(a); // =&gt;200</code></pre><h2 id="3、const"><a href="#3、const" class="headerlink" title="3、const"></a>3、const</h2><blockquote><p>基于ES6中的const创建一个变量，让其指向1000，但后期让其指向2000，会报错，因此const创建的值是不能改变，所以const是常量</p></blockquote><pre><code>const b=1000;      b=2000;console.log(b); // =&gt;TypeError: Assignment to constant variable.</code></pre><h2 id="4、function"><a href="#4、function" class="headerlink" title="4、function"></a>4、function</h2><blockquote><p>创建一个函数，也可以理解为创建了一个fun，让其指向这个函数</p></blockquote><pre><code>function fun()&#123;&#125;;conosle.log(fun); // =&gt;ƒ fun() &#123;&#125;</code></pre><h2 id="5、class类"><a href="#5、class类" class="headerlink" title="5、class类"></a>5、class类</h2><blockquote><p>创建一个类也可以理解创建了一个变量Parent,让其指向这个类</p></blockquote><pre><code>class Parent&#123;&#125;;cosnole.log(Parent); // =&gt; class Parent &#123; &#125;</code></pre><h2 id="6、import-require"><a href="#6、import-require" class="headerlink" title="6、import/require"></a>6、import/require</h2><blockquote><p>基于模块规范来导入具体的某个模块，定义一个axios的变量，用来指向导入的这个模块</p></blockquote><pre><code>// 导入axios模块import axios from &#39;axios&#39;;// 导入axios模块let axios=require(&#39;./axions&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序的对云数据库的增删改查</title>
      <link href="//micrud/"/>
      <url>//micrud/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序的对云数据库的增删改查"><a href="#微信小程序的对云数据库的增删改查" class="headerlink" title="微信小程序的对云数据库的增删改查"></a>微信小程序的对云数据库的增删改查</h1><h2 id="创建数据的类型"><a href="#创建数据的类型" class="headerlink" title="*创建数据的类型"></a>*创建数据的类型</h2><table><thead><tr><th align="center">类型</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">Bumber</td><td align="center">字符串类型  ‘a’ ,’b’</td></tr><tr><td align="center">Number</td><td align="center">数值类型  0 1 2 3</td></tr><tr><td align="center">Boolean</td><td align="center">布尔值类型  true || false</td></tr><tr><td align="center">Object</td><td align="center">对象类型 obj:{num:1,name:’哈利波特’}</td></tr><tr><td align="center">Null</td><td align="center">空值</td></tr><tr><td align="center">Array</td><td align="center">数组  list:[‘item1’,’item2]</td></tr><tr><td align="center">Date</td><td align="center">时间类型</td></tr><tr><td align="center">Geopoint</td><td align="center">位置类型</td></tr></tbody></table><h2 id="一、查询数据"><a href="#一、查询数据" class="headerlink" title="一、查询数据"></a>一、查询数据</h2><h4 id="1、云函数查询数据库数据"><a href="#1、云函数查询数据库数据" class="headerlink" title="1、云函数查询数据库数据"></a>1、云函数查询数据库数据</h4><pre><code>// 文件名称为getData    // 云函数入口文件    const cloud=require(&#39;wx-server-sdk&#39;);    // 初始化    cloud.init()    // 连接数据库    const db=cloud.database();    导出数据    exports.main = async (event, context) =&gt;&#123;        // 查询数据库数据并返回        return await db.collection(&#39;数据库名称&#39;).get()    &#125;</code></pre><h4 id="2、本地查询数据库数据"><a href="#2、本地查询数据库数据" class="headerlink" title="2、本地查询数据库数据"></a>2、本地查询数据库数据</h4><pre><code>// 调用云函数数据wx.cloud.callection(&#123;    // 云函数名称    name:&#39;getData&#39;&#125;).then(res=&gt;&#123;    console.log(res)&#125;)-------------------------------------------//本地查询数据库数据    // 连接数据库    const db=wx.cloud.database()    // 查询数据    db.collection(&#39;数据库名称&#39;).get().then(res=&gt;&#123;        console.log(res)    &#125;)</code></pre><h2 id="二、添加数据"><a href="#二、添加数据" class="headerlink" title="二、添加数据"></a>二、添加数据</h2><h4 id="1、云函数添加数据"><a href="#1、云函数添加数据" class="headerlink" title="1、云函数添加数据"></a>1、云函数添加数据</h4><pre><code>// 文件名为 getData// 云函数入口文件const cloud = require(&#39;wx-server-sdk&#39;)// 初始化cloud.init()// 连接数据库const db = cloud.database()// 云函数入口函数exports.main = async (event, context) =&gt; &#123;// 将添加完的数据返回到本地  return await db.collection(&#39;数据库名称&#39;).add(&#123;  // 要创建的数据    data: &#123;     name:&#39;哈利波特&#39;,     age:20,     sex:&#39;男&#39;，     marriage：false    &#125;  &#125;)&#125; </code></pre><h4 id="2、本地添加数据和调用云函数"><a href="#2、本地添加数据和调用云函数" class="headerlink" title="2、本地添加数据和调用云函数"></a>2、本地添加数据和调用云函数</h4><pre><code>// 调用云函数创建的数据 wx.cloud.callFunction(&#123; // 云函数名称 name:&#39;getData&#39; &#125;).then(res=&gt;&#123;     conosle.log(res)   &#125;)--------------------------------------------------------- // 本地向数据库添加用户 // 本地连接数据库    const db=wx.cloud.database();    db.collection(&#39;数据库名称&#39;).add(&#123;        // 要创建的数据        data: &#123;         name:&#39;哈利波特&#39;,         age:20,         sex:&#39;男&#39;，         marriage：false        &#125;    &#125;).then(res=&gt;&#123;        console.log(res)    &#125;)</code></pre><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>​    在云函数中添加数据是没有用户的openid的,在本地创建的数据自带用户openid</p><h2 id="三、删除数据"><a href="#三、删除数据" class="headerlink" title="三、删除数据"></a>三、删除数据</h2><h4 id="1、云函数删除数据库数据"><a href="#1、云函数删除数据库数据" class="headerlink" title="1、云函数删除数据库数据"></a>1、云函数删除数据库数据</h4><pre><code>// 文件名为delDataconst cloud=require(wx-server-sdk);//初始化cloud.init();const db=cloud.database();exports.main= async (event,context)=&gt;&#123;    // 删除数据库数据并返回    return await db.collection(&#39;数据库名字&#39;).doc(&#39;要删除数据的id&#39;).remove()&#125;</code></pre><h4 id="2、-本地删除数据库数据和调用云函数"><a href="#2、-本地删除数据库数据和调用云函数" class="headerlink" title="2、 本地删除数据库数据和调用云函数"></a>2、 本地删除数据库数据和调用云函数</h4><pre><code>// 调用云函数删除数据wx.cloud.callFuction(&#123;    // 要删除的问函数名称    name:&#39;delData&#39;&#125;).then(res=&gt;&#123;    console.log(res)&#125;)-----------------------------------------------------// 本地删除数据库数据、    //连接数据库    const db=wx.cloud.database();    db.collection(&#39;text&#39;).doc(&#39;要删除的数据id&#39;).remove().then(res=&gt;&#123;        console.log(res)    &#125;)</code></pre><h6 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h6><p>本地删除操作默认只能删除自己在本地创建的数据，不能删除云开发控制台和云函数中常见的数据，如：需求是在本地删除数据，请在云控制台中的数据库修改权限</p><h2 id="四、修改数据"><a href="#四、修改数据" class="headerlink" title="四、修改数据"></a>四、修改数据</h2><h4 id="1、-云函数中修改数据"><a href="#1、-云函数中修改数据" class="headerlink" title="1、 云函数中修改数据"></a>1、 云函数中修改数据</h4><pre><code>// 文件名为updateDataconst cloud=require(&#39;wx-server-sdk&#39;);cloud.init()const db=cloud.database()exports.main= async (event, context) =&gt; &#123;    // 修改部分数据并返回    return await db.collection(&#39;数据库名称&#39;).doc(&#39;要修改的数据id&#39;).update(&#123;    // 要修改的值        data:&#123;            name:&#39;赫敏&#39;，            age:30        &#125;    &#125;)&#125;</code></pre><h4 id="2、本地修改数据库数据和调用云函数"><a href="#2、本地修改数据库数据和调用云函数" class="headerlink" title="2、本地修改数据库数据和调用云函数"></a>2、本地修改数据库数据和调用云函数</h4><pre><code>// 调用云函数wx.cloud.callection(&#123;    name:&#39;updateData&#39;&#125;).then(res=&gt;&#123;    console.log(res)&#125;)--------------------------------------------// 本地修改数据库数据const db=wx.cloud.database();db.collection(&#39;数据库名称&#39;).doc(&#39;要修改的数据id&#39;).update(&#123;    // 要修改的数据    data:&#123;        name:&#39;卢娜&#39;，        age:30    &#125;&#125;).then(res=&gt;&#123;    console.log(res)&#125;)</code></pre><h6 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h6><p>  本地调用和云函数的区别只在于</p><ul><li>云函数权限大</li><li>本地操作要在代码前要添加wx.什么什么</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node将明文密码加密</title>
      <link href="//nobcrypt/"/>
      <url>//nobcrypt/</url>
      
        <content type="html"><![CDATA[<h3 id="今天给大家介绍一款Node密码加密的模块-bcrypt"><a href="#今天给大家介绍一款Node密码加密的模块-bcrypt" class="headerlink" title="今天给大家介绍一款Node密码加密的模块 bcrypt"></a>今天给大家介绍一款Node密码加密的模块 bcrypt</h3><ol><li><h5 id="使用bcrypt模块加密前确保本机存在python环境"><a href="#使用bcrypt模块加密前确保本机存在python环境" class="headerlink" title="使用bcrypt模块加密前确保本机存在python环境"></a>使用bcrypt模块加密前确保本机存在python环境</h5><p><a href="https://www.python.org/">python官网</a></p></li><li><h5 id="下载bacrypt模块"><a href="#下载bacrypt模块" class="headerlink" title="下载bacrypt模块"></a>下载bacrypt模块</h5><pre><code>npm install bcrypt</code></pre></li><li><h5 id="在本地项目中导入bcrypt模块"><a href="#在本地项目中导入bcrypt模块" class="headerlink" title="在本地项目中导入bcrypt模块"></a>在本地项目中导入bcrypt模块</h5><pre><code>const bcrypt = require(&#39;bcrypt&#39;)</code></pre></li><li><h5 id="生成盐-（理论下值于高，越不容易被破解）"><a href="#生成盐-（理论下值于高，越不容易被破解）" class="headerlink" title="生成盐  （理论下值于高，越不容易被破解）"></a>生成盐  （理论下值于高，越不容易被破解）</h5><pre><code>const salt = await bcrypt.genSalt(10) /*  * 注意:  *      1、生成的盐是异步操作  *      2、数值表示加密的强度 0-10  */ </code></pre></li><li><h5 id="将密码进行加密处理"><a href="#将密码进行加密处理" class="headerlink" title="将密码进行加密处理"></a>将密码进行加密处理</h5><pre><code>const newPass=await bcrypt.hash(pass,salt)/* * 注意 *   1、 加密密码是异步操作 *   2、salt是第四步生生成的盐，pass是要加密的值，newPass是加密后的新密码 */</code></pre></li><li><h5 id="验证密码是否加密成功"><a href="#验证密码是否加密成功" class="headerlink" title="验证密码是否加密成功"></a>验证密码是否加密成功</h5><pre><code>const isOk= await bcrypt.compare(newPass,pass)console.log(isok) // false || true/* * 注意: *   1、验证密码是异步操作 *   2、新密码与旧密码比对，如果成功返回true,失败返回false */</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> bcrypt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript关于数组方法</title>
      <link href="//jsarray/"/>
      <url>//jsarray/</url>
      
        <content type="html"><![CDATA[<h3 id="Array-forEach-v-i-callback"><a href="#Array-forEach-v-i-callback" class="headerlink" title="Array.forEach(v,i,callback)"></a>Array.forEach(v,i,callback)</h3><ol><li>作用 :循环数组</li><li>形参：</li></ol><ul><li><p>v : 当前循环项</p></li><li><p>i :  当前循环项索引</p></li><li><p>callback: 回调函数</p></li></ul><pre><code>const array = [    &#123;    id:0,    name:&#39;孙为空&#39;    &#125;,    &#123;    id:1,    name:&#39;猪八戒&#39;    &#125;,    &#123;    id:2,    name:&#39;沙悟净&#39;    &#125;,    &#123;    id:3,    name:&#39;唐三藏&#39;    &#125;]array.forEach((v,i)=&gt;&#123;    consoel.log(v,i)&#125;)// 输出:&#123;id:0,name:&#39;孙悟空&#39;&#125;,&#123;id:1,name:&#39;猪八戒&#39;&#125;,&#123;id:2,name:&#39;沙悟净&#39;&#125;,&#123;id:3,name:&#39;唐三藏&#39;&#125;</code></pre><h3 id="Array-filter-v-i-callback"><a href="#Array-filter-v-i-callback" class="headerlink" title="Array.filter(v,i,callback)"></a>Array.filter(v,i,callback)</h3><ol><li>作用 : 过滤数组,并返回新数组</li><li>形参：</li></ol><ul><li>v : 当前循环项</li><li>i :  当前循环项索引</li><li>callback: 回调函数</li></ul><pre><code>const num = [10,15,20,25]const newNum = num.filter((v,i)=&gt;&#123;    return v &gt;= 15&#125;)console.log(newNum)//输出:    [15, 20, 25]</code></pre><h3 id="Array-map-v-i-callback"><a href="#Array-map-v-i-callback" class="headerlink" title="Array.map(v,i,callback)"></a>Array.map(v,i,callback)</h3><ol><li>作用 : 返回数组中指定的值</li><li>形参：*同上</li></ol><pre><code>const list = [    &#123;     name:&#39;张三&#39;,     age:20    &#125;,    &#123;     name:&#39;李四&#39;,     age:25    &#125;,    &#123;     name:&#39;王五&#39;,     age:27    &#125;]const newList = list.map((v,i)=&gt;&#123;    return v.name&#125;)console.log(newList)// 输出:    [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</code></pre><h3 id="Array-findIndex-v-i-callback"><a href="#Array-findIndex-v-i-callback" class="headerlink" title="Array.findIndex(v,i,callback)"></a>Array.findIndex(v,i,callback)</h3><ol><li>作用 : 返回符合条件的索引 </li><li>形参：*同上</li><li>注意：如果找到符合条件的值，立即结束循环并返回索引</li><li>索引：索引是从0开始计算的</li></ol><pre><code>const num = [10,20,30,40]const index = num.findIndex((v,i)=&gt;&#123;    return v &gt; 25&#125;)console.log(index)// 输出:    2</code></pre><h3 id="Array-every-v-i-callback"><a href="#Array-every-v-i-callback" class="headerlink" title="Array.every(v,i,callback)"></a>Array.every(v,i,callback)</h3><ol><li>作用 : 判断数组中的值符合条件，并返回布尔值 false || true</li><li>形参：*同上</li><li>注意：数组中只要有一个不符合条件，都会返回false,并立即结束循环</li></ol><pre><code>const num = [20,30,40,50]const bool = num.every((v,i)=&gt;&#123;    console.log(v)    return v &lt;= 30&#125;)console.log(bool)// 输出:    20    30    40    false</code></pre><h3 id="Array-some-v-i-callback"><a href="#Array-some-v-i-callback" class="headerlink" title="Array.some(v,i,callback)"></a>Array.some(v,i,callback)</h3><ol><li>作用 : 判断数组中的值符合条件，并返回布尔值 false || true</li><li>形参：*同上</li><li>注意：数组中只要有一个符合条件，都会返回true,并立即结束循环</li></ol><pre><code>const num = [10,20,30,40]const bool=num.some((v,i)=&gt;&#123;    console.log(v)    return v&gt;=30&#125;)console.log(bool)// 输出:    10    20    30    true</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb数据加密</title>
      <link href="//modb/"/>
      <url>//modb/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>打开终端</strong> （如：cmd || powershell 等等…）</p></li><li><p>输入  <strong>mongo</strong></p></li><li><p><strong>show dbs</strong>   //查询数据列表</p></li><li><p><strong>use admin</strong>  //切换至admin数据库</p></li><li><p><strong>db.createUser({user:’用户名’，pwd:’设置管理员密码’，roles:[‘root’]})</strong>  //创建超级管理员</p><ol><li><p>role: 管理权限</p></li><li><p>参数：</p><ul><li><p>root:超级管理员权限，可对任意数据库进行增删改查</p></li><li><p>read能读取该数据库的内容，但不能进心修改</p></li><li><p>readwrite:   可以对该数据库进行增删改查</p></li></ul></li></ol></li><li><p><strong>use text</strong>   //创建并进入text数据库</p></li><li><p><strong>db.createUser({user:’用户名‘，pwd:’密码’，roles:[‘readWhite’]})</strong>        //创建普通管理员</p><pre><code>// 创建代码    db.createUser(&#123;user:&#39;text&#39;,pwd:&#39;teal&#39;,roles:[&#39;readWrite&#39;]&#125;)// 成功提示    Successfully added user: &#123; &quot;user&quot; : &quot;text&quot;, &quot;roles&quot; : [ &quot;readWrite&quot; ] &#125;</code></pre></li><li><p><strong>edit</strong>  //退出</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="//text/"/>
      <url>//text/</url>
      
        <content type="html"><![CDATA[<h1 id="我是测试文章请勿评论"><a href="#我是测试文章请勿评论" class="headerlink" title="我是测试文章请勿评论"></a>我是测试文章请勿评论</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
